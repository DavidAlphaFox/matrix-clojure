<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ChangeListManager">
    <list default="true" id="ef97d307-f487-4c12-a37c-953b69f2764e" name="Default" comment="" />
    <ignored path="$PROJECT_DIR$/target/" />
    <option name="EXCLUDED_CONVERTED_TO_IGNORED" value="true" />
    <option name="TRACKING_ENABLED" value="true" />
    <option name="SHOW_DIALOG" value="false" />
    <option name="HIGHLIGHT_CONFLICTS" value="true" />
    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
    <option name="LAST_RESOLUTION" value="IGNORE" />
  </component>
  <component name="FileEditorManager">
    <leaf SIDE_TABS_SIZE_LIMIT_KEY="300">
      <file leaf-file-name="project.clj" pinned="false" current-in-tab="false">
        <entry file="file://$PROJECT_DIR$/project.clj">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="0">
              <caret line="0" column="39" lean-forward="false" selection-start-line="0" selection-start-column="39" selection-end-line="0" selection-end-column="39" />
              <folding />
            </state>
          </provider>
        </entry>
      </file>
      <file leaf-file-name="base.cljc" pinned="false" current-in-tab="false">
        <entry file="file://$PROJECT_DIR$/src/tiltontec/model/base.cljc">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="372">
              <caret line="78" column="18" lean-forward="false" selection-start-line="78" selection-start-column="18" selection-end-line="78" selection-end-column="18" />
              <folding />
            </state>
          </provider>
        </entry>
      </file>
      <file leaf-file-name="evaluate.cljc" pinned="false" current-in-tab="true">
        <entry file="file://$PROJECT_DIR$/src/tiltontec/cell/evaluate.cljc">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="269">
              <caret line="405" column="5" lean-forward="false" selection-start-line="405" selection-start-column="5" selection-end-line="405" selection-end-column="5" />
              <folding />
            </state>
          </provider>
        </entry>
      </file>
      <file leaf-file-name="core.cljc" pinned="false" current-in-tab="false">
        <entry file="file://$PROJECT_DIR$/src/tiltontec/model/core.cljc">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="464">
              <caret line="150" column="15" lean-forward="false" selection-start-line="150" selection-start-column="15" selection-end-line="150" selection-end-column="15" />
              <folding />
            </state>
          </provider>
        </entry>
      </file>
      <file leaf-file-name="core.cljc" pinned="false" current-in-tab="false">
        <entry file="file://$PROJECT_DIR$/src/tiltontec/util/core.cljc">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="260">
              <caret line="53" column="6" lean-forward="false" selection-start-line="53" selection-start-column="6" selection-end-line="53" selection-end-column="6" />
              <folding />
            </state>
          </provider>
        </entry>
      </file>
      <file leaf-file-name="synapse.cljc" pinned="false" current-in-tab="false">
        <entry file="file://$PROJECT_DIR$/src/tiltontec/cell/synapse.cljc">
          <provider selected="true" editor-type-id="text-editor">
            <state relative-caret-position="435">
              <caret line="29" column="55" lean-forward="false" selection-start-line="29" selection-start-column="55" selection-end-line="29" selection-end-column="55" />
              <folding />
            </state>
          </provider>
        </entry>
      </file>
    </leaf>
  </component>
  <component name="FileTemplateManagerImpl">
    <option name="RECENT_TEMPLATES">
      <list>
        <option value="ClojureScript Namespace" />
        <option value="CLJC Namespace" />
        <option value="Clojure Test Namespace" />
      </list>
    </option>
  </component>
  <component name="FindInProjectRecents">
    <findStrings>
      <find>throw</find>
      <find>send-xhr</find>
      <find>unbound</find>
      <find>make-xhr</find>
      <find>Exception.</find>
      <find>xhr-error?</find>
      <find>pprint</find>
      <find>github</find>
      <find>make-todo</find>
      <find>building</find>
      <find>c-value-ass</find>
      <find>c-reset!</find>
      <find>with-integrity</find>
      <find>:items-active</find>
      <find>:items-completed</find>
      <find>:cslot</find>
      <find>:uawake</find>
      <find>:cvass</find>
      <find>c-reset</find>
      <find>noslot-obs</find>
      <find>map-to-json</find>
      <find>client</find>
      <find>:kids</find>
      <find>noslot-</find>
      <find>async</find>
      <find>trx</find>
      <find>no</find>
      <find>nonslo</find>
      <find>not-to-be</find>
      <find>not2be</find>
    </findStrings>
    <replaceStrings>
      <replace>c-slot</replace>
      <replace />
      <replace>xhr-ok-body</replace>
    </replaceStrings>
    <dirStrings>
      <dir>$PROJECT_DIR$/test/</dir>
      <dir>$PROJECT_DIR$/test</dir>
      <dir>$PROJECT_DIR$/src</dir>
      <dir>$PROJECT_DIR$</dir>
    </dirStrings>
  </component>
  <component name="Git.Settings">
    <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$/.." />
  </component>
  <component name="GradleLocalSettings">
    <option name="externalProjectsViewState">
      <projects_view />
    </option>
  </component>
  <component name="IdeDocumentHistory">
    <option name="CHANGED_PATHS">
      <list>
        <option value="$PROJECT_DIR$/startwatch.html" />
        <option value="$PROJECT_DIR$/css/startwatch.css" />
        <option value="$PROJECT_DIR$/test/tiltontec/cell/synapse.cljc" />
        <option value="$PROJECT_DIR$/test/tiltontec/cell/XHR/core.clj" />
        <option value="$PROJECT_DIR$/test/tiltontec/XHR/core.clj" />
        <option value="$PROJECT_DIR$/src/tiltontec/tag/gen.cljc" />
        <option value="$PROJECT_DIR$/test/tiltontec/xhr/core.clj" />
        <option value="$PROJECT_DIR$/test/tiltontec/xhr/core.cljc" />
        <option value="$PROJECT_DIR$/src/tiltontec/util/base.cljc" />
        <option value="$PROJECT_DIR$/src/tiltontec/cell/base.cljc" />
        <option value="$PROJECT_DIR$/src/todomx/ticktock.cljs" />
        <option value="$PROJECT_DIR$/test/tiltontec/cell/synapse_test.cljc" />
        <option value="$PROJECT_DIR$/src/tiltontec/model/core.cljc" />
        <option value="$PROJECT_DIR$/src/tiltontec/util/core.cljc" />
        <option value="$PROJECT_DIR$/test/tiltontec/xhr/core_test.cljc" />
        <option value="$PROJECT_DIR$/src/tiltontec/xhr/core.cljc" />
        <option value="$PROJECT_DIR$/src/tiltontec/tag/html.cljs" />
        <option value="$PROJECT_DIR$/src/todomx/matrix.cljs" />
        <option value="$PROJECT_DIR$/src/tiltontec/cell/integrity.cljc" />
        <option value="$PROJECT_DIR$/src/todomx/todo.cljs" />
        <option value="$PROJECT_DIR$/src/tiltontec/cell/core.cljc" />
        <option value="$PROJECT_DIR$/src/todomx/todomvc.cljs" />
        <option value="$PROJECT_DIR$/src/todomx/startwatch.cljs" />
        <option value="$PROJECT_DIR$/src/todomx/core.cljs" />
        <option value="$PROJECT_DIR$/src/tiltontec/cell/synapse.cljc" />
        <option value="$PROJECT_DIR$/src/example/gentle_intro.cljs" />
        <option value="$PROJECT_DIR$/src/tiltontec/model/base.cljc" />
        <option value="$PROJECT_DIR$/project.clj" />
        <option value="$PROJECT_DIR$/src/tiltontec/cell/evaluate.cljc" />
      </list>
    </option>
  </component>
  <component name="ProjectFrameBounds">
    <option name="x" value="218" />
    <option name="y" value="67" />
    <option name="width" value="1494" />
    <option name="height" value="922" />
  </component>
  <component name="ProjectLevelVcsManager">
    <ConfirmationsSetting value="2" id="Add" />
  </component>
  <component name="ProjectView">
    <navigator currentView="ProjectPane" proportions="" version="1">
      <flattenPackages />
      <showMembers />
      <showModules />
      <showLibraryContents />
      <hideEmptyPackages />
      <abbreviatePackageNames />
      <autoscrollToSource />
      <autoscrollFromSource />
      <sortByType />
      <manualOrder />
      <foldersAlwaysOnTop value="true" />
    </navigator>
    <panes>
      <pane id="AndroidView" />
      <pane id="ProjectPane">
        <subPane>
          <expand>
            <path>
              <item name="cljs" type="b2602c69:ProjectViewProjectNode" />
              <item name="cljs" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="cljs" type="b2602c69:ProjectViewProjectNode" />
              <item name="cljs" type="462c0819:PsiDirectoryNode" />
              <item name="resources" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="cljs" type="b2602c69:ProjectViewProjectNode" />
              <item name="cljs" type="462c0819:PsiDirectoryNode" />
              <item name="src" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="cljs" type="b2602c69:ProjectViewProjectNode" />
              <item name="cljs" type="462c0819:PsiDirectoryNode" />
              <item name="src" type="462c0819:PsiDirectoryNode" />
              <item name="tiltontec" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="cljs" type="b2602c69:ProjectViewProjectNode" />
              <item name="cljs" type="462c0819:PsiDirectoryNode" />
              <item name="src" type="462c0819:PsiDirectoryNode" />
              <item name="tiltontec" type="462c0819:PsiDirectoryNode" />
              <item name="cell" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="cljs" type="b2602c69:ProjectViewProjectNode" />
              <item name="cljs" type="462c0819:PsiDirectoryNode" />
              <item name="src" type="462c0819:PsiDirectoryNode" />
              <item name="tiltontec" type="462c0819:PsiDirectoryNode" />
              <item name="model" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="cljs" type="b2602c69:ProjectViewProjectNode" />
              <item name="cljs" type="462c0819:PsiDirectoryNode" />
              <item name="src" type="462c0819:PsiDirectoryNode" />
              <item name="tiltontec" type="462c0819:PsiDirectoryNode" />
              <item name="util" type="462c0819:PsiDirectoryNode" />
            </path>
            <path>
              <item name="cljs" type="b2602c69:ProjectViewProjectNode" />
              <item name="cljs" type="462c0819:PsiDirectoryNode" />
              <item name="target" type="462c0819:PsiDirectoryNode" />
            </path>
          </expand>
          <select />
        </subPane>
      </pane>
      <pane id="PackagesPane" />
      <pane id="Scope" />
      <pane id="Scratches" />
    </panes>
  </component>
  <component name="PropertiesComponent">
    <property name="last_opened_file_path" value="$PROJECT_DIR$" />
    <property name="cursive.last.file.extension./Users/kennethtilton/todoFRP/todo/MatrixCLJS/src" value="cljc" />
    <property name="project.structure.last.edited" value="Modules" />
    <property name="project.structure.proportion" value="0.15" />
    <property name="project.structure.side.proportion" value="0.2" />
    <property name="settings.editor.selected.configurable" value="Keybindings" />
    <property name="cursive.last.file.extension./Users/kennethtilton/todoFRP/todo/MatrixCLJS/test" value="clj" />
  </component>
  <component name="RecentsManager">
    <key name="CopyFile.RECENT_KEYS">
      <recent name="$PROJECT_DIR$" />
    </key>
  </component>
  <component name="ReplState" timestamp="1514097404063">{:repl-history {:ide [], :local [{:command &quot;(ns tiltontec.xhr.core\n  (:require\n    [#?(:cljs cljs.pprint :clj clojure.pprint) :refer [pprint cl-format]]\n\n    [tiltontec.util.core :refer [pln]]\n\n    #?(:cljs [tiltontec.cell.base\n              :refer-macros [pcell un-stopped without-c-dependency cpr]\n\n              :refer [+pulse+ c-pulse c-optimized-away?\n                      +client-q-handler+ c-stopped unbound\n                      *within-integrity* *defer-changes*\n                      *depender* caller-ensure]]\n       :clj [tiltontec.cell.base :refer :all])\n\n    #?(:cljs [tiltontec.cell.synapse\n              :refer-macros [with-synapse]\n              :refer []]\n       :clj\n    [tiltontec.cell.synapse :refer :all])\n\n    #?(:cljs [tiltontec.util.base\n              :refer-macros [trx prog1 *trx?* def-rmap-slots]]\n       :clj\n    [tiltontec.util.base\n     :refer :all])\n\n    #?(:clj\n    [tiltontec.cell.observer :refer [fn-obs observe observe-by-type]]\n       :cljs [tiltontec.cell.observer\n              :refer-macros [fn-obs]\n              :refer [observe observe-by-type]])\n\n    #?(:cljs [tiltontec.cell.integrity\n              :refer-macros [with-integrity]]\n       :clj\n    [tiltontec.cell.integrity :refer [with-integrity with-cc]])\n\n    #?(:clj\n    [tiltontec.cell.core :refer :all]\n       :cljs [tiltontec.cell.core\n              :refer-macros [c? c?+ c_? c?_]\n              :refer [c-in c-reset! make-c-formula]])\n\n    [tiltontec.model.core\n     :refer-macros [the-kids mdv!]\n     :refer [md-get fasc fm! make md-reset! backdoor-reset!\n             mx-par]\n     :as md]\n\n\n    #?(:clj\n    [clj-http.client :as client]\n       :cljs [cljs-http.client :as client])\n\n    [cheshire.core :refer :all]))&quot;, :offset 1673, :ns &quot;tiltontec.xhr.core&quot;} {:command &quot;(defn xhr-status-key [xhr]\n  (xhr-status xhr))&quot;, :offset 46, :ns &quot;tiltontec.xhr.core&quot;} {:command &quot;(ns tiltontec.xhr.core-test\n  (:require\n    [clojure.test :refer :all]\n    [clojure.set :as set]\n    [#?(:cljs cljs.pprint :clj clojure.pprint) :refer [pprint cl-format]]\n    [tiltontec.util.core :refer [pln xor now *plnk-keys*]]\n    [tiltontec.cell.evaluate :refer [c-get c-awaken not-to-be]]\n\n    #?(:clj\n    [tiltontec.cell.base :refer :all]\n       :cljs [tiltontec.cell.base\n              :refer-macros [without-c-dependency]\n              :refer [cells-init +pulse+ unbound cpr]])\n    [tiltontec.cell.integrity :refer [*dp-log*]]\n    [tiltontec.cell.core :refer :all]\n\n    #?(:clj\n    [tiltontec.model.core :refer :all]\n       :cljs [tiltontec.model.core\n              :refer-macros [the-kids mdv!]\n              :refer [md-get fasc fm! make md-reset! backdoor-reset!\n                      mx-par]\n              :as md])\n\n    [tiltontec.xhr.core\n     :refer [make-xhr send-xhr xhr-response xhr-send xhr-await xhr-status\n             xhr-status-key xhr-resolved xhr-error? xhrfo synaptic-xhr]]\n\n    #?(:clj\n    [tiltontec.cell.synapse :refer :all]\n       :cljs [tiltontec.cell.synapse\n              :refer-macros [with-synapse]\n              :refer []])\n\n    #?(:clj\n    [tiltontec.cell.observer :refer [fn-obs]]\n       :cljs [tiltontec.cell.observer :refer-macros [fn-obs]])\n\n    #?(:clj\n    [tiltontec.tag.gen :refer :all]\n       :cljs [tiltontec.tag.gen :refer [evt-tag target-value] :refer-macros [h1 input div]])\n\n    [cheshire.core :refer :all]\n\n    #?(:clj\n      [clj-http.client :as client]\n      :cljs [cljs-http.client :as client])))&quot;, :offset 1547, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(ns tiltontec.xhr.core-test\n  (:require\n    [clojure.test :refer :all]\n    [clojure.string :as str]\n    [clojure.set :as set]\n    [#?(:cljs cljs.pprint :clj clojure.pprint) :refer [pprint cl-format]]\n    [tiltontec.util.core :refer [pln xor now *plnk-keys*]]\n    [tiltontec.cell.evaluate :refer [c-get c-awaken not-to-be]]\n\n    #?(:clj\n    [tiltontec.cell.base :refer :all]\n       :cljs [tiltontec.cell.base\n              :refer-macros [without-c-dependency]\n              :refer [cells-init +pulse+ unbound cpr]])\n    [tiltontec.cell.integrity :refer [*dp-log*]]\n    [tiltontec.cell.core :refer :all]\n\n    #?(:clj\n    [tiltontec.model.core :refer :all]\n       :cljs [tiltontec.model.core\n              :refer-macros [the-kids mdv!]\n              :refer [md-get fasc fm! make md-reset! backdoor-reset!\n                      mx-par]\n              :as md])\n\n    [tiltontec.xhr.core\n     :refer [make-xhr send-xhr xhr-response xhr-send xhr-await xhr-status\n             xhr-status-key xhr-resolved xhr-error? xhrfo synaptic-xhr]]\n\n    #?(:clj\n    [tiltontec.cell.synapse :refer :all]\n       :cljs [tiltontec.cell.synapse\n              :refer-macros [with-synapse]\n              :refer []])\n\n    #?(:clj\n    [tiltontec.cell.observer :refer [fn-obs]]\n       :cljs [tiltontec.cell.observer :refer-macros [fn-obs]])\n\n    #?(:clj\n    [tiltontec.tag.gen :refer :all]\n       :cljs [tiltontec.tag.gen :refer [evt-tag target-value] :refer-macros [h1 input div]])\n\n    [cheshire.core :refer :all]\n\n    #?(:clj\n      [clj-http.client :as client]\n      :cljs [cljs-http.client :as client])))&quot;, :offset 1576, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(deftest fda-adderall-syntax-error\n  (let [xhr (xhr-await (send-xhr (str/replace ae-adderall #\&quot;search\&quot; \&quot;surch\&quot;)))]\n    (is (not= 200 (xhr-status xhr)))))&quot;, :offset 153, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(ns tiltontec.xhr.core-test\n  (:require\n    [clojure.test :refer :all]\n    [clojure.string :as str]\n    [clojure.set :as set]\n    [#?(:cljs cljs.pprint :clj clojure.pprint) :refer [pprint cl-format]]\n    [tiltontec.util.core :refer [pln xor now *plnk-keys*]]\n    [tiltontec.cell.evaluate :refer [c-get c-awaken not-to-be]]\n\n    #?(:clj\n    [tiltontec.cell.base :refer :all]\n       :cljs [tiltontec.cell.base\n              :refer-macros [without-c-dependency]\n              :refer [cells-init +pulse+ unbound cpr]])\n    [tiltontec.cell.integrity :refer [*dp-log*]]\n    [tiltontec.cell.core :refer :all]\n\n    #?(:clj\n    [tiltontec.model.core :refer :all]\n       :cljs [tiltontec.model.core\n              :refer-macros [the-kids mdv!]\n              :refer [md-get fasc fm! make md-reset! backdoor-reset!\n                      mx-par]\n              :as md])\n\n    [tiltontec.xhr.core\n     :refer [make-xhr send-xhr xhr-response xhr-send xhr-await xhr-status\n             xhr-status-key xhr-resolved xhr-error? xhrfo synaptic-xhr\n             xhr-selection]]\n\n    #?(:clj\n    [tiltontec.cell.synapse :refer :all]\n       :cljs [tiltontec.cell.synapse\n              :refer-macros [with-synapse]\n              :refer []])\n\n    #?(:clj\n    [tiltontec.cell.observer :refer [fn-obs]]\n       :cljs [tiltontec.cell.observer :refer-macros [fn-obs]])\n\n    #?(:clj\n    [tiltontec.tag.gen :refer :all]\n       :cljs [tiltontec.tag.gen :refer [evt-tag target-value] :refer-macros [h1 input div]])\n\n    [cheshire.core :refer :all]\n\n    #?(:clj\n      [clj-http.client :as client]\n      :cljs [cljs-http.client :as client])))&quot;, :offset 1603, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(deftest fda-adderall-ok\n  (let [xhr (xhr-await (send-xhr ae-adderall))]\n    (is (= 200 (xhr-status xhr)))\n     (println :boom (keys (xhr-selection xhr)))))&quot;, :offset 156, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(defn xhr-send [xhr]\n  (let [uri (md-get xhr :uri)]\n    (cpr :xhr-awaken-sending uri )\n\n    (with-integrity (:awaken xhr)\n      (cpr :xhr-actually-send-ing uri )\n\n      #?(:clj (client/get uri\n                {:async? true}\n                (fn [response]\n                  (cpr :xhr-response!!! (:status response) uri)\n                  (if (mdead? xhr)\n                    (do (cpr :ignoring-response-to-dead-XHR!!! uri (meta xhr)))\n                    (with-cc :xhr-handler-sets-responded\n                      ;;(cpr :xhr-handler-sets-responded @xhr xhr)\n                      (md-reset! xhr :response {:status (:status response)\n                                                    :body (parse-string (:body response) true)}))))\n                (fn [exception]\n                  (let [edata (:data (bean exception))]\n                    (cpr :xhr-exception!!! uri (:status edata) (parse-string (:body edata) true))\n                    (when-not (mdead? xhr)\n                      (with-cc :xhr-handler-sets-error\n                        (cpr :xhr-handler-sets-error)\n                        (md-reset! xhr :response {:status (:status edata)\n                                                  :body (parse-string (:body edata) true)}))))))))))&quot;, :offset 1245, :ns &quot;tiltontec.xhr.core&quot;} {:command &quot;(deftest fda-adderall-ok\n  (let [xhr (xhr-await (send-xhr ae-adderall))]\n    (is (= 200 (xhr-status xhr)))\n     (println :boom (do (get (xhr-selection xhr) :meta)))))&quot;, :offset 166, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(deftest fda-adderall-ok\n  (let [xhr (xhr-await (send-xhr ae-adderall))]\n    (is (= 200 (xhr-status xhr)))\n     (println :boom (type (:results (xhr-selection xhr))))))&quot;, :offset 167, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(def ae-adderall \&quot;https://api.fda.gov/drug/event.json?search=patient.drug.openfda.brand_name:adderall&amp;limit=3\&quot;)&quot;, :offset 111, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(deftest fda-adderall-ok\n  (let [xhr (xhr-await (send-xhr ae-adderall))]\n    (is (= 200 (xhr-status xhr)))\n     (println :boom (count (:results (xhr-selection xhr))))))&quot;, :offset 168, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(deftest fda-adderall-ok\n  (let [xhr (xhr-await (send-xhr ae-adderall))]\n    (is (= 200 (xhr-status xhr)))\n    (is (= 3 (count (:results (xhr-selection xhr)))))))&quot;, :offset 162, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(deftest fda-adderall-ok\n  (let [xhr (xhr-await (send-xhr ae-adderall))]\n    (is (= 200 (xhr-status xhr)))\n    (is (= 3 (count (:results (xhr-selection xhr)))))\n    (let [ae (first (:results (xhr-selection xhr)))]\n      (pln :ae (keys ae)))))&quot;, :offset 242, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(deftest fda-adverse-lite\n  ;; for 3 AEs\n  ;;   for each drug taken by patient\n  ;;     get the labeling\n  ;;     get up to 3 recall notices from the manufacturer\n  (let [top (make-xhr ae-adderall\n              {:send? false\n               :kids  (c? (cpr :kidrule!!!!!!)\n                          (when-let [aes (:results (xhr-selection xhr))]\n                            (println :bingo-patients!)\n                            (doseq [p (map :patient aes)]\n                              (println :drug-ct (count (:drug p))))\n                            nil)\n                          #_(when-let [parent (xhr-resolved me)]\n                            (the-kids\n                              (make-xhr \&quot;http://yahoo.com\&quot;\n                                {:par   me\n                                 :send? true})\n                              (make-xhr \&quot;http://youtube.com\&quot;\n                                {:par   me\n                                 :send? true}))))})]\n\n    (xhr-send top)\n    (when (xhr-await top)\n      (pln :waited!!!!!!!!!)\n      (when (xhr-response top)\n        (pln :esponse!!!!!!!!!!!!!)\n        (is (= 200 (xhr-status-key top)))\n        (is (= 0 (count (md-kids top))))\n        #_ (doseq [k (md-kids top)]\n          (xhr-await k)\n          (do                                             ;; when (xhr-resolved k)\n            (is (= :responded (xhr-status-key k))))))\n      (println :fini!!!!!!!!))))&quot;, :offset 1422, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(deftest fda-adverse-lite\n  ;; for 3 AEs\n  ;;   for each drug taken by patient\n  ;;     get the labeling\n  ;;     get up to 3 recall notices from the manufacturer\n  (let [top (make-xhr ae-adderall\n              {:send? false\n               :kids  (c? (cpr :kidrule!!!!!!)\n                          (when-let [aes (:results (xhr-selection me))]\n                            (println :bingo-patients!)\n                            (doseq [p (map :patient aes)]\n                              (println :drug-ct (count (:drug p))))\n                            nil)\n                          #_(when-let [parent (xhr-resolved me)]\n                            (the-kids\n                              (make-xhr \&quot;http://yahoo.com\&quot;\n                                {:par   me\n                                 :send? true})\n                              (make-xhr \&quot;http://youtube.com\&quot;\n                                {:par   me\n                                 :send? true}))))})]\n\n    (xhr-send top)\n    (when (xhr-await top)\n      (pln :waited!!!!!!!!!)\n      (when (xhr-response top)\n        (pln :esponse!!!!!!!!!!!!!)\n        (is (= 200 (xhr-status-key top)))\n        (is (= 0 (count (md-kids top))))\n        #_ (doseq [k (md-kids top)]\n          (xhr-await k)\n          (do                                             ;; when (xhr-resolved k)\n            (is (= :responded (xhr-status-key k))))))\n      (println :fini!!!!!!!!))))&quot;, :offset 1421, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(def drug-label\n  \&quot;https://api.fda.gov/drug/label.json?search=openfda.product_ndc:~a\&quot;)&quot;, :offset 86, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(deftest fda-adverse-lite\n  ;; for 3 AEs\n  ;;   for each drug taken by patient\n  ;;     get the labeling\n  ;;     get up to 3 recall notices from the manufacturer\n  (let [top (make-xhr ae-adderall\n              {:send? true\n               :kids  (c? #_\n                          (when-let [aes (:results (xhr-selection me))]\n                            (println :bingo-patients!)\n                            (doseq [p (map :patient aes)]\n                              (println :pkeys (keys (:openfda (first (:drug p)))))\n                              ;(println :drug-ct (map #(first (:product-ndc %)) (:drug p)))\n                              )\n                            nil)\n\n                        (when-let [aes (:results (xhr-selection me))]\n                          (pln :got-aes!!!! (count aes))\n                          (the-kids\n                            (for [ae aes]\n                              (make ::md/family\n                                :name :adverse-event\n                                :ae (dissoc ae :patient)\n                                :patient (dissoc (:patient ae) :drug)\n                                :kids (c? (the-kids\n                                            (for [drug (:drug (:patient ae))\n                                                  :let [ndc (get-in drug [:openfda :product_ndc])]]\n                                              (make-xhr (cl-format drug-label ndc)\n                                                {:send? true\n                                                 :dbg ndc})\n                                              #_\n                                              (make-xhr-group\n                                                :name :patient-drug\n                                                :kids (C? (the-kids\n                                                            (make-xhr (cl-format ae-label ndc))\n                                                            (make-xhr (cl-format ae-recalls ndc)))))))))))))})]\n\n    \n    (when (xhr-await top)\n      (pln :top-waited!!!!!!!!!)\n      (when (xhr-response top)\n        (pln :top-response!!!!!!!!!!!!!)\n        (is (= 200 (xhr-status-key top)))\n        (is (= 3 (count (md-kids top))))\n        (doseq [k (md-kids top)]\n          (xhr-await k)\n          (do\n            (pln :ae (:name @ae))\n            (is (= 200 (xhr-status-key k))))))\n      (println :fini!!!!!!!!))))&quot;, :offset 2404, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(deftest fda-adverse-lite\n  ;; for 3 AEs\n  ;;   for each drug taken by patient\n  ;;     get the labeling\n  ;;     get up to 3 recall notices from the manufacturer\n  (let [top (make-xhr ae-adderall\n              {:send? true\n               :kids  (c? #_\n                          (when-let [aes (:results (xhr-selection me))]\n                            (println :bingo-patients!)\n                            (doseq [p (map :patient aes)]\n                              (println :pkeys (keys (:openfda (first (:drug p)))))\n                              ;(println :drug-ct (map #(first (:product-ndc %)) (:drug p)))\n                              )\n                            nil)\n\n                        (when-let [aes (:results (xhr-selection me))]\n                          (pln :got-aes!!!! (count aes))\n                          (the-kids\n                            (for [ae aes]\n                              (make ::md/family\n                                :name :adverse-event\n                                :ae (dissoc ae :patient)\n                                :patient (dissoc (:patient ae) :drug)\n                                :kids (c? (the-kids\n                                            (for [drug (:drug (:patient ae))\n                                                  :let [ndc (get-in drug [:openfda :product_ndc])]]\n                                              (make-xhr (cl-format drug-label ndc)\n                                                {:send? true\n                                                 :dbg ndc})\n                                              #_\n                                              (make-xhr-group\n                                                :name :patient-drug\n                                                :kids (C? (the-kids\n                                                            (make-xhr (cl-format ae-label ndc))\n                                                            (make-xhr (cl-format ae-recalls ndc)))))))))))))})]\n\n    \n    (when (xhr-await top)\n      (pln :top-waited!!!!!!!!!)\n      (when (xhr-response top)\n        (pln :top-response!!!!!!!!!!!!!)\n        (is (= 200 (xhr-status-key top)))\n        (is (= 3 (count (md-kids top))))\n        (doseq [ae (md-kids top)]\n          (do\n            (pln :ae (xhr-status-key ae) (:name @ae) (:ae @ae))\n            (is (= 200 (xhr-status-key ae))))))\n      (println :fini!!!!!!!!))))&quot;, :offset 2412, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(defn xhr-send [xhr]\n  (let [uri (md-get xhr :uri)]\n    (cpr :xhr-awaken-sending uri )\n\n    (with-integrity (:awaken xhr)\n      (cpr :xhr-actually-send-ing uri )\n\n      #?(:clj (client/get uri\n                {:async? true}\n                (fn [response]\n                  (cpr :xhr-response!!! (:status response) uri)\n                  (if (mdead? xhr)\n                    (do (cpr :ignoring-response-to-dead-XHR!!! uri (meta xhr)))\n                    (with-cc :xhr-handler-sets-responded\n                      ;;(cpr :xhr-handler-sets-responded @xhr xhr)\n                      (md-reset! xhr :response {:status (:status response)\n                                                    :body (parse-string (:body response) true)}))))\n                (fn [exception]\n                  (let [edata (:data (bean exception))]\n                    \n                    (cpr :xhr-exception!!! uri (:status edata) (parse-string (:body edata) true))\n                    (pprint (bean exception))\n                    (when-not (mdead? xhr)\n                      (with-cc :xhr-handler-sets-error\n                        (cpr :xhr-handler-sets-error)\n                        (md-reset! xhr :response {:status (:status edata)\n                                                  :body (parse-string (:body edata) true)}))))))))))&quot;, :offset 1312, :ns &quot;tiltontec.xhr.core&quot;} {:command &quot;(defn xhr-send [xhr]\n  (let [uri (md-get xhr :uri)]\n    (cpr :xhr-awaken-sending uri )\n\n    (with-integrity (:awaken xhr)\n      (cpr :xhr-actually-send-ing uri )\n\n      #?(:clj (client/get uri\n                {:async? true}\n                (fn [response]\n                  (cpr :xhr-response!!! (:id @xhr)(:status response) uri)\n                  (if (mdead? xhr)\n                    (do (cpr :ignoring-response-to-dead-XHR!!! uri (meta xhr)))\n                    (with-cc :xhr-handler-sets-responded\n                      (cpr :xhr-handler-sets-responded @xhr xhr)\n                      (md-reset! xhr :response {:status (:status response)\n                                                    :body (parse-string (:body response) true)}))))\n                (fn [exception]\n                  (let [edata (:data (bean exception))]\n\n                    (cpr :xhr-exception!!! (:id @xhr) uri (:status edata) (parse-string (:body edata) true))\n                    (pprint (bean exception))\n                    (when-not (mdead? xhr)\n                      (with-cc :xhr-handler-sets-error\n                        (cpr :xhr-handler-sets-error)\n                        (md-reset! xhr :response {:status (:status edata)\n                                                  :body (parse-string (:body edata) true)}))))))))))&quot;, :offset 1311, :ns &quot;tiltontec.xhr.core&quot;} {:command &quot;(defn make-xhr\n  ([uri]\n   (make-xhr uri {}))\n\n  ([uri attrs]\n   (assert (string? uri) (str \&quot;param uri &lt;\&quot; uri \&quot;&gt; not a string\&quot;))\n   (let [xhr (apply make\n                    :type :tiltontec.xhr.core/xhr\n                    :id (swap! +xhr-sid+ inc) ;; debug aid\n                    :uri uri\n                    :response (c-in nil)\n                    :select nil\n                    :selection (c? (when-let [b (xhr-ok-body me)]\n                                    (if-let [ks (md-get me :select)]\n                                      (select-keys b ks)\n                                      b)))\n                    (vec (apply concat (seq (dissoc attrs :send?)))))]\n     (when (:send? attrs)\n       (xhr-send xhr))\n     xhr)))&quot;, :offset 731, :ns &quot;tiltontec.xhr.core&quot;} {:command &quot;(defn xhr-send [xhr]\n  (let [uri (md-get xhr :uri)]\n    (cpr :xhr-awaken-sending uri )\n\n    (with-integrity (:awaken xhr)\n      (cpr :xhr-actually-send-ing uri )\n\n      #?(:clj (client/get uri\n                {:async? true}\n                (fn [response]\n                  (cpr :xhr-response!!! (:id @xhr)(:status response) uri)\n                  (if (mdead? xhr)\n                    (do (cpr :ignoring-response-to-dead-XHR!!! uri (meta xhr)))\n                    (with-cc :xhr-handler-sets-responded\n                      (cpr :xhr-handler-sets-responded @xhr xhr)\n                      (md-reset! xhr :response {:status (:status response)\n                                                :body \&quot;soon\&quot; #_ (parse-string (:body response) true)}))))\n                (fn [exception]\n                  (let [edata (:data (bean exception))]\n\n                    (cpr :xhr-exception!!! (:id @xhr) uri (:status edata) (parse-string (:body edata) true))\n                    (pprint (bean exception))\n                    (when-not (mdead? xhr)\n                      (with-cc :xhr-handler-sets-error\n                        (cpr :xhr-handler-sets-error)\n                        (md-reset! xhr :response {:status (:status edata)\n                                                  :body (parse-string (:body edata) true)}))))))))))&quot;, :offset 1317, :ns &quot;tiltontec.xhr.core&quot;} {:command &quot;(defn make-xhr\n  ([uri]\n   (make-xhr uri {}))\n\n  ([uri attrs]\n   (assert (string? uri) (str \&quot;param uri &lt;\&quot; uri \&quot;&gt; not a string\&quot;))\n   (let [xhr (apply make\n                    :type :tiltontec.xhr.core/xhr\n                    :id (swap! +xhr-sid+ inc) ;; debug aid\n                    :uri uri\n                    :response (c-in nil)\n                    :select nil\n                    :selection (c? (when-let [b (xhr-ok-body me)]\n                                     (pln :sel-sees-body!! b)\n                                    (if-let [ks (md-get me :select)]\n                                      (select-keys b ks)\n                                      b)))\n                    (vec (apply concat (seq (dissoc attrs :send?)))))]\n     (when (:send? attrs)\n       (xhr-send xhr))\n     xhr)))&quot;, :offset 793, :ns &quot;tiltontec.xhr.core&quot;} {:command &quot;(defn xhr-send [xhr]\n  (let [uri (md-get xhr :uri)]\n    (cpr :xhr-awaken-sending uri )\n\n    (with-integrity (:awaken xhr)\n      (cpr :xhr-actually-send-ing uri )\n\n      #?(:clj (client/get uri\n                {:async? true}\n                (fn [response]\n                  (cpr :xhr-response!!! (:id @xhr)(:status response) uri)\n                  (if (mdead? xhr)\n                    (do (cpr :ignoring-response-to-dead-XHR!!! uri (meta xhr)))\n                    (with-cc :xhr-handler-sets-responded\n                      (cpr :xhr-handler-sets-responded @xhr xhr)\n                      (cpr :xhr-handler-body (:body response))\n                      (md-reset! xhr :response {:status (:status response)\n                                                :body \&quot;soon\&quot; #_ (parse-string (:body response) true)}))))\n                (fn [exception]\n                  (let [edata (:data (bean exception))]\n\n                    (cpr :xhr-exception!!! (:id @xhr) uri (:status edata) (parse-string (:body edata) true))\n                    (pprint (bean exception))\n                    (when-not (mdead? xhr)\n                      (with-cc :xhr-handler-sets-error\n                        (cpr :xhr-handler-sets-error)\n                        (md-reset! xhr :response {:status (:status edata)\n                                                  :body (parse-string (:body edata) true)}))))))))))&quot;, :offset 1380, :ns &quot;tiltontec.xhr.core&quot;} {:command &quot;(defn xhr-send [xhr]\n  (let [uri (md-get xhr :uri)]\n    (cpr :xhr-awaken-sending uri )\n\n    (with-integrity (:awaken xhr)\n      (cpr :xhr-actually-send-ing uri )\n\n      #?(:clj (client/get uri\n                {:async? true}\n                (fn [response]\n                  (cpr :xhr-response!!! (:id @xhr)(:status response) uri)\n                  (if (mdead? xhr)\n                    (do (cpr :ignoring-response-to-dead-XHR!!! uri (meta xhr)))\n                    (with-cc :xhr-handler-sets-responded\n                      (cpr :xhr-handler-sets-responded @xhr xhr)\n                      (cpr :xhr-handler-body (parse-string (:body response) true))\n                      (md-reset! xhr :response {:status (:status response)\n                                                :body \&quot;soon\&quot; #_ (parse-string (:body response) true)}))))\n                (fn [exception]\n                  (let [edata (:data (bean exception))]\n\n                    (cpr :xhr-exception!!! (:id @xhr) uri (:status edata) (parse-string (:body edata) true))\n                    (pprint (bean exception))\n                    (when-not (mdead? xhr)\n                      (with-cc :xhr-handler-sets-error\n                        (cpr :xhr-handler-sets-error)\n                        (md-reset! xhr :response {:status (:status edata)\n                                                  :body (parse-string (:body edata) true)}))))))))))&quot;, :offset 1400, :ns &quot;tiltontec.xhr.core&quot;} {:command &quot;(defn xhr-send [xhr]\n  (let [uri (md-get xhr :uri)]\n    (cpr :xhr-awaken-sending uri )\n\n    (with-integrity (:awaken xhr)\n      (cpr :xhr-actually-send-ing uri )\n\n      #?(:clj (client/get uri\n                {:async? true}\n                (fn [response]\n                  (cpr :xhr-response!!! (:id @xhr)(:status response) uri)\n                  (if (mdead? xhr)\n                    (do (cpr :ignoring-response-to-dead-XHR!!! uri (meta xhr)))\n                    (with-cc :xhr-handler-sets-responded\n                      (cpr :xhr-handler-sets-responded @xhr xhr)\n                      (cpr :xhr-handler-body)\n                      (pprint (parse-string (:body response) true))\n                      (md-reset! xhr :response {:status (:status response)\n                                                :body \&quot;soon\&quot; #_ (parse-string (:body response) true)}))))\n                (fn [exception]\n                  (let [edata (:data (bean exception))]\n\n                    (cpr :xhr-exception!!! (:id @xhr) uri (:status edata) (parse-string (:body edata) true))\n                    (pprint (bean exception))\n                    (when-not (mdead? xhr)\n                      (with-cc :xhr-handler-sets-error\n                        (cpr :xhr-handler-sets-error)\n                        (md-reset! xhr :response {:status (:status edata)\n                                                  :body (parse-string (:body edata) true)}))))))))))&quot;, :offset 1431, :ns &quot;tiltontec.xhr.core&quot;} {:command &quot;(defn xhr-send [xhr]\n  (let [uri (md-get xhr :uri)]\n    (cpr :xhr-awaken-sending uri )\n\n    (with-integrity (:awaken xhr)\n      (cpr :xhr-actually-send-ing uri )\n\n      #?(:clj (client/get uri\n                {:async? true}\n                (fn [response]\n                  (cpr :xhr-response!!! (:id @xhr)(:status response) uri)\n                  (if (mdead? xhr)\n                    (do (cpr :ignoring-response-to-dead-XHR!!! uri (meta xhr)))\n                    (with-cc :xhr-handler-sets-responded\n                      (cpr :xhr-handler-sets-responded @xhr xhr)\n                      (cpr :xhr-handler-body)\n                      ;; (pprint (parse-string (:body response) true))\n                      (md-reset! xhr :response {:status (:status response)\n                                                :body (parse-string (:body response) true)}))))\n                (fn [exception]\n                  (let [edata (:data (bean exception))]\n\n                    (cpr :xhr-exception!!! (:id @xhr) uri (:status edata) (parse-string (:body edata) true))\n                    (pprint (bean exception))\n                    (when-not (mdead? xhr)\n                      (with-cc :xhr-handler-sets-error\n                        (cpr :xhr-handler-sets-error)\n                        (md-reset! xhr :response {:status (:status edata)\n                                                  :body (parse-string (:body edata) true)}))))))))))&quot;, :offset 1424, :ns &quot;tiltontec.xhr.core&quot;} {:command &quot;(defn make-xhr\n  ([uri]\n   (make-xhr uri {}))\n\n  ([uri attrs]\n   (assert (string? uri) (str \&quot;param uri &lt;\&quot; uri \&quot;&gt; not a string\&quot;))\n   (let [xhr (apply make\n                    :type :tiltontec.xhr.core/xhr\n                    :id (swap! +xhr-sid+ inc) ;; debug aid\n                    :uri uri\n                    :response (c-in nil)\n                    :select nil\n                    :selection (c? (when-let [b (xhr-ok-body me)]\n                                     (pln :sel-sees-body!! (md-get me :select) b)\n                                    (if-let [ks (md-get me :select)]\n                                      (select-keys b ks)\n                                      b)))\n                    (vec (apply concat (seq (dissoc attrs :send?)))))]\n     (when (:send? attrs)\n       (xhr-send xhr))\n     xhr)))&quot;, :offset 813, :ns &quot;tiltontec.xhr.core&quot;} {:command &quot;(deftest fda-adverse-lite\n  ;; for 3 AEs\n  ;;   for each drug taken by patient\n  ;;     get the labeling\n  ;;     get up to 3 recall notices from the manufacturer\n  (let [top (make-xhr ae-adderall\n              {:send? true\n               :kids  (c? #_\n                          (when-let [aes (:results (xhr-selection me))]\n                            (println :bingo-patients!)\n                            (doseq [p (map :patient aes)]\n                              (println :pkeys (keys (:openfda (first (:drug p)))))\n                              ;(println :drug-ct (map #(first (:product-ndc %)) (:drug p)))\n                              )\n                            nil)\n\n                        (when-let [aes (:results (xhr-selection me))]\n                          (pln :got-aes!!!! (count aes))\n                          (the-kids\n                            (for [ae aes]\n                              (pln :ae!!!!!!!)\n                              nil #_\n                              (make ::md/family\n                                :name :adverse-event\n                                :ae (dissoc ae :patient)\n                                :patient (dissoc (:patient ae) :drug)\n                                :kids (c? (the-kids\n                                            (for [drug (:drug (:patient ae))\n                                                  :let [ndc (get-in drug [:openfda :product_ndc])]]\n                                              (make-xhr (cl-format drug-label ndc)\n                                                {:send? true\n                                                 :dbg ndc})\n                                              #_\n                                              (make-xhr-group\n                                                :name :patient-drug\n                                                :kids (C? (the-kids\n                                                            (make-xhr (cl-format ae-label ndc))\n                                                            (make-xhr (cl-format ae-recalls ndc)))))))))))))})]\n\n\n    (when (xhr-await top)\n      (pln :top-waited!!!!!!!!!)\n      (when (xhr-response top)\n        (pln :top-response!!!!!!!!!!!!! (xhr-status-key top))\n        (is (= 200 (xhr-status-key top) ))\n        (is (= 3 (count (md-kids top))))\n        (doseq [ae (md-kids top)]\n          (do\n            (pln :ae (xhr-status-key ae) (:name @ae) (:ae @ae))\n            (is (= 200 (xhr-status-key ae))))))\n      (println :fini!!!!!!!!))))&quot;, :offset 2514, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(deftest fda-adverse-lite\n  ;; for 3 AEs\n  ;;   for each drug taken by patient\n  ;;     get the labeling\n  ;;     get up to 3 recall notices from the manufacturer\n  (let [top (make-xhr ae-adderall\n              {:send? true\n               :kids  (c? #_\n                          (when-let [aes (:results (xhr-selection me))]\n                            (println :bingo-patients!)\n                            (doseq [p (map :patient aes)]\n                              (println :pkeys (keys (:openfda (first (:drug p)))))\n                              ;(println :drug-ct (map #(first (:product-ndc %)) (:drug p)))\n                              )\n                            nil)\n\n                        (when-let [aes (:results (xhr-selection me))]\n                          (pln :got-aes!!!! (count aes))\n                          (the-kids\n                            (for [ae aes]\n                              (do (pln :ae!!!!!!!)\n                              nil #_\n                              (make ::md/family\n                                :name :adverse-event\n                                :ae (dissoc ae :patient)\n                                :patient (dissoc (:patient ae) :drug)\n                                :kids (c? (the-kids\n                                            (for [drug (:drug (:patient ae))\n                                                  :let [ndc (get-in drug [:openfda :product_ndc])]]\n                                              (make-xhr (cl-format drug-label ndc)\n                                                {:send? true\n                                                 :dbg ndc})\n                                              #_\n                                              (make-xhr-group\n                                                :name :patient-drug\n                                                :kids (C? (the-kids\n                                                            (make-xhr (cl-format ae-label ndc))\n                                                            (make-xhr (cl-format ae-recalls ndc))))))))))))))})]\n\n\n    (when (xhr-await top)\n      (pln :top-waited!!!!!!!!!)\n      (when (xhr-response top)\n        (pln :top-response!!!!!!!!!!!!! (xhr-status-key top))\n        (is (= 200 (xhr-status-key top) ))\n        (is (= 3 (count (md-kids top))))\n        (doseq [ae (md-kids top)]\n          (do\n            (pln :ae (xhr-status-key ae) (:name @ae) (:ae @ae))\n            (is (= 200 (xhr-status-key ae))))))\n      (println :fini!!!!!!!!))))&quot;, :offset 2519, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(defn xhr-send [xhr]\n  (let [uri (md-get xhr :uri)]\n    (cpr :xhr-send-sending uri )\n\n    (do ;; with-integrity (:awaken xhr)\n      (cpr :xhr-actually-send-ing uri )\n\n      #?(:clj (client/get uri\n                {:async? true}\n                (fn [response]\n                  (cpr :xhr-response!!! (:id @xhr)(:status response) uri)\n                  (if (mdead? xhr)\n                    (do (cpr :ignoring-response-to-dead-XHR!!! uri (meta xhr)))\n                    (with-cc :xhr-handler-sets-responded\n                      (cpr :xhr-handler-sets-responded @xhr xhr)\n                      (cpr :xhr-handler-body)\n                      ;; (pprint (parse-string (:body response) true))\n                      (md-reset! xhr :response {:status (:status response)\n                                                :body (parse-string (:body response) true)}))))\n                (fn [exception]\n                  (let [edata (:data (bean exception))]\n\n                    (cpr :xhr-exception!!! (:id @xhr) uri (:status edata) (parse-string (:body edata) true))\n                    (pprint (bean exception))\n                    (when-not (mdead? xhr)\n                      (with-cc :xhr-handler-sets-error\n                        (cpr :xhr-handler-sets-error)\n                        (md-reset! xhr :response {:status (:status edata)\n                                                  :body (parse-string (:body edata) true)}))))))))))&quot;, :offset 1428, :ns &quot;tiltontec.xhr.core&quot;} {:command &quot;(defn xhr-await\n  ([xhr] (xhr-await xhr 3))\n  ([xhr max-seconds]\n\n   (cond\n     (xhr-response xhr)\n     (do (println :xhr-resolved (xhrfo xhr))\n         xhr)\n\n     (&gt; max-seconds 0)\n     #?(:clj  (do\n                (println :xhr-await-sleeping (xhrfo xhr))\n                (Thread/sleep 1000)\n                (recur xhr (dec max-seconds)))\n        :cljs (js/setTimeout (fn [] (xhr-await xhr (dec max-seconds))) 1000))\n\n     :default (do (println :xhr-await-timeout! (xhrfo xhr))\n                  nil))))&quot;, :offset 505, :ns &quot;tiltontec.xhr.core&quot;} {:command &quot;(defn xhr-send [xhr]\n  (let [uri (md-get xhr :uri)]\n    (cpr :xhr-send-sending uri )\n\n    (do ;; with-integrity (:awaken xhr)\n      (cpr :xhr-actually-send-ing uri )\n\n      #?(:clj (client/get uri\n                {:async? true}\n                (fn [response]\n                  (cpr :xhr-response!!! (:id @xhr)(:status response) uri)\n                  (if (mdead? xhr)\n                    (do (cpr :ignoring-response-to-dead-XHR!!! uri (meta xhr)))\n                    (with-cc :xhr-handler-sets-responded\n                      (cpr :xhr-handler-sets-responded @xhr xhr)\n                      (cpr :xhr-handler-body)\n                      ;; (pprint (parse-string (:body response) true))\n                      (md-reset! xhr :response {:status (:status response)\n                                                :body (parse-string (:body response) true)}))))\n                (fn [exception]\n                  (let [edata (:data (bean exception))]\n\n                    (cpr :xhr-exception!!! (:id @xhr) uri (:status edata) (parse-string (:body edata) true))\n                    (pprint (dissoc (bean exception) :stackTrace))\n                    (when-not (mdead? xhr)\n                      (with-cc :xhr-handler-sets-error\n                        (cpr :xhr-handler-sets-error)\n                        (md-reset! xhr :response {:status (:status edata)\n                                                  :body (parse-string (:body edata) true)}))))))))))&quot;, :offset 1449, :ns &quot;tiltontec.xhr.core&quot;} {:command &quot;(defn make-xhr\n  ([uri]\n   (make-xhr uri {}))\n\n  ([uri attrs]\n   (assert (string? uri) (str \&quot;param uri &lt;\&quot; uri \&quot;&gt; not a string\&quot;))\n   (let [xhr (apply make\n                    :type :tiltontec.xhr.core/xhr\n                    :id (swap! +xhr-sid+ inc) ;; debug aid\n                    :uri uri\n                    :response (c-in nil)\n                    :select nil\n                    :selection (c? (when-let [b (xhr-ok-body me)]\n                                     (pln :sel-sees-body!! (md-get me :select) b)\n                                    (if-let [ks (md-get me :select)]\n                                      (select-keys b ks)\n                                      b)))\n                    (vec (apply concat (seq (dissoc attrs :send?)))))]\n     (cpr :made!!!!!!!!!!)\n     (when (:send? attrs)\n       (cpr :make-xhr-sending uri)\n       (xhr-send xhr))\n     xhr)))&quot;, :offset 875, :ns &quot;tiltontec.xhr.core&quot;} {:command &quot;(defn xhr-send [xhr]\n  (let [uri (md-get xhr :uri)]\n    (cpr :xhr-send-sending uri )\n\n    (do ;; with-integrity (:awaken xhr)\n      (cpr :xhr-actually-send-ing uri )\n\n      #?(:clj (client/get uri\n                {:async? true}\n                (fn [response]\n                  (cpr :xhr-response!!! (:id @xhr)(:status response) uri)\n                  (if (mdead? xhr)\n                    (do (cpr :ignoring-response-to-dead-XHR!!! uri (meta xhr)))\n                    (do (cpr :hitting-with-cc)\n                        (with-cc :xhr-handler-sets-responded\n                      \n                      (cpr :xhr-handler-body)\n                      (cpr :xhr-handler-sets-responded @xhr xhr)\n                      ;; (pprint (parse-string (:body response) true))\n                      (md-reset! xhr :response {:status (:status response)\n                                                :body (parse-string (:body response) true)})))))\n                (fn [exception]\n                  (let [edata (:data (bean exception))]\n\n                    (cpr :xhr-exception!!! (:id @xhr) uri (:status edata) (parse-string (:body edata) true))\n                    (pprint (dissoc (bean exception) :stackTrace))\n                    (when-not (mdead? xhr)\n                      (with-cc :xhr-handler-sets-error\n                        (cpr :xhr-handler-sets-error)\n                        (md-reset! xhr :response {:status (:status edata)\n                                                  :body (parse-string (:body edata) true)}))))))))))&quot;, :offset 1524, :ns &quot;tiltontec.xhr.core&quot;} {:command &quot;(defn xhr-send [xhr]\n  (let [uri (md-get xhr :uri)]\n    (cpr :xhr-send-sending uri )\n\n    (do ;; with-integrity (:awaken xhr)\n      (cpr :xhr-actually-send-ing uri )\n\n      #?(:clj (client/get uri\n                {:async? true}\n                (fn [response]\n                  (cpr :xhr-response!!! (:id @xhr)(:status response) uri)\n                  (if (mdead? xhr)\n                    (do (cpr :ignoring-response-to-dead-XHR!!! uri (meta xhr)))\n                    (do (cpr :hitting-with-cc *within-integrity*)\n                        (with-cc :xhr-handler-sets-responded\n\n                      (cpr :xhr-handler-body)\n                      (cpr :xhr-handler-sets-responded @xhr xhr)\n                      ;; (pprint (parse-string (:body response) true))\n                      (md-reset! xhr :response {:status (:status response)\n                                                :body (parse-string (:body response) true)})))))\n                (fn [exception]\n                  (let [edata (:data (bean exception))]\n\n                    (cpr :xhr-exception!!! (:id @xhr) uri (:status edata) (parse-string (:body edata) true))\n                    (pprint (dissoc (bean exception) :stackTrace))\n                    (when-not (mdead? xhr)\n                      (with-cc :xhr-handler-sets-error\n                        (cpr :xhr-handler-sets-error)\n                        (md-reset! xhr :response {:status (:status edata)\n                                                  :body (parse-string (:body edata) true)}))))))))))&quot;, :offset 1521, :ns &quot;tiltontec.xhr.core&quot;} {:command &quot;(defn call-with-integrity [opcode defer-info action]\n  (when opcode\n    (assert (cl-find opcode +ufb-opcodes+)\n            (str \&quot;Invalid opcode for with-integrity: %s. Allowed values: %s\&quot;\n                    opcode +ufb-opcodes+)))\n  (do                                                       ;; wtrx (0 100 \&quot;cwi-begin\&quot; opcode *within-integrity*)\n    (un-stopped\n     (do                                                    ;;#?(:cljs do :clj dosync)\n      (cond\n        (c-stopped) (println :cwi-sees-stop!!!!!!!!!!!)\n\n        *within-integrity*\n        (if opcode\n          (prog1\n           :deferred-to-ufb-1\n           ;; SETF is supposed to return the value being installed\n           ;; in the place, but if the SETF is deferred we return\n           ;; something that will help someone who tries to use\n           ;; the setf'ed value figure out what is going on:\n           (pln :cwi-defers opcode (first (ensure-vec defer-info)))\n           (ufb-add opcode [defer-info action]))\n\n          ;; thus by not supplying an opcode one can get something\n          ;; executed immediately, potentially breaking data integrity\n          ;; but signifying by having coded the with-integrity macro\n          ;; that one is aware of this.\n          ;;\n          ;; If you have read this comment.\n          ;;\n          (do\n          ;;(pln :cwi-bypassing-integrity!!! opcode defer-info)\n          (action opcode defer-info)))\n\n        :else (binding [*within-integrity* true\n                        *defer-changes* false]\n                (println :cwi-go-1)\n                (when (or (zero? @+pulse+)\n                          (= opcode :change))\n                  (data-pulse-next [:cwi opcode defer-info]))\n                (pln :cwi-action!! opcode )\n                (prog1\n                 (action opcode defer-info)\n\n                 (finish-business)\n                 (ufb-assert-q-empty :tell-dependents)\n                 (ufb-assert-q-empty :change))))))))&quot;, :offset 1958, :ns &quot;tiltontec.cell.integrity&quot;} {:command &quot;(defn call-with-integrity [opcode defer-info action]\n  (when opcode\n    (assert (cl-find opcode +ufb-opcodes+)\n            (str \&quot;Invalid opcode for with-integrity: %s. Allowed values: %s\&quot;\n                    opcode +ufb-opcodes+)))\n  (do                                                       ;; wtrx (0 100 \&quot;cwi-begin\&quot; opcode *within-integrity*)\n    (un-stopped\n     #?(:cljs do :clj dosync)\n      (cond\n        (c-stopped) (println :cwi-sees-stop!!!!!!!!!!!)\n\n        *within-integrity*\n        (if opcode\n          (prog1\n           :deferred-to-ufb-1\n           ;; SETF is supposed to return the value being installed\n           ;; in the place, but if the SETF is deferred we return\n           ;; something that will help someone who tries to use\n           ;; the setf'ed value figure out what is going on:\n           (pln :cwi-defers opcode (first (ensure-vec defer-info)))\n           (ufb-add opcode [defer-info action]))\n\n          ;; thus by not supplying an opcode one can get something\n          ;; executed immediately, potentially breaking data integrity\n          ;; but signifying by having coded the with-integrity macro\n          ;; that one is aware of this.\n          ;;\n          ;; If you have read this comment.\n          ;;\n          (do\n          ;;(pln :cwi-bypassing-integrity!!! opcode defer-info)\n          (action opcode defer-info)))\n\n        :else (binding [*within-integrity* true\n                        *defer-changes* false]\n                (println :cwi-go-1)\n                (when (or (zero? @+pulse+)\n                          (= opcode :change))\n                  (data-pulse-next [:cwi opcode defer-info]))\n                (pln :cwi-action!! opcode )\n                (prog1\n                 (action opcode defer-info)\n\n                 (finish-business)\n                 (ufb-assert-q-empty :tell-dependents)\n                 (ufb-assert-q-empty :change)))))))&quot;, :offset 1900, :ns &quot;tiltontec.cell.integrity&quot;} {:command &quot;(defn call-with-integrity [opcode defer-info action]\n  (when opcode\n    (assert (cl-find opcode +ufb-opcodes+)\n            (str \&quot;Invalid opcode for with-integrity: %s. Allowed values: %s\&quot;\n                    opcode +ufb-opcodes+)))\n  (do                                                       ;; wtrx (0 100 \&quot;cwi-begin\&quot; opcode *within-integrity*)\n    (un-stopped\n     (#?(:cljs do :clj dosync)\n      (cond\n        (c-stopped) (println :cwi-sees-stop!!!!!!!!!!!)\n\n        *within-integrity*\n        (if opcode\n          (prog1\n           :deferred-to-ufb-1\n           ;; SETF is supposed to return the value being installed\n           ;; in the place, but if the SETF is deferred we return\n           ;; something that will help someone who tries to use\n           ;; the setf'ed value figure out what is going on:\n           (pln :cwi-defers opcode (first (ensure-vec defer-info)))\n           (ufb-add opcode [defer-info action]))\n\n          ;; thus by not supplying an opcode one can get something\n          ;; executed immediately, potentially breaking data integrity\n          ;; but signifying by having coded the with-integrity macro\n          ;; that one is aware of this.\n          ;;\n          ;; If you have read this comment.\n          ;;\n          (do\n          ;;(pln :cwi-bypassing-integrity!!! opcode defer-info)\n          (action opcode defer-info)))\n\n        :else (binding [*within-integrity* true\n                        *defer-changes* false]\n                (println :cwi-go-1)\n                (when (or (zero? @+pulse+)\n                          (= opcode :change))\n                  (data-pulse-next [:cwi opcode defer-info]))\n                (pln :cwi-action!! opcode )\n                (prog1\n                 (action opcode defer-info)\n\n                 (finish-business)\n                 (ufb-assert-q-empty :tell-dependents)\n                 (ufb-assert-q-empty :change))))))))&quot;, :offset 1902, :ns &quot;tiltontec.cell.integrity&quot;} {:command &quot;(deftest fda-adverse-lite\n  ;; for 3 AEs\n  ;;   for each drug taken by patient\n  ;;     get the labeling\n  ;;     get up to 3 recall notices from the manufacturer\n  (let [top (make-xhr ae-adderall ;; (cl-format ae-brand \&quot;adderall\&quot; 1)\n              {:send? true\n               :kids  (c? #_(when-let [aes (:results (xhr-selection me))]\n                              (println :bingo-patients!)\n                              (doseq [p (map :patient aes)]\n                                (println :pkeys (keys (:openfda (first (:drug p)))))\n                                ;(println :drug-ct (map #(first (:product-ndc %)) (:drug p)))\n                                )\n                              nil)\n\n                        (when-let [aes (:results (xhr-selection me))]\n                          (pln :got-aes!!!! (count aes))\n                          (the-kids\n                            (for [ae aes]\n                              (do (pln :ae!!!!!!!)\n\n                                  (make ::md/family\n                                    :name :adverse-event\n                                    :ae (dissoc ae :patient)\n                                    :patient (dissoc (:patient ae) :drug)\n                                    :kids (c? (the-kids\n                                                (for [drug (:drug (:patient ae))\n                                                      :let [ndc (get-in drug [:openfda :product_ndc])]]\n                                                  (make-xhr (cl-format drug-label ndc)\n                                                    {:send? true\n                                                     :dbg   ndc})\n                                                  #_(make-xhr-group\n                                                      :name :patient-drug\n                                                      :kids (C? (the-kids\n                                                                  (make-xhr (cl-format ae-label ndc))\n                                                                  (make-xhr (cl-format ae-recalls ndc))))))))))))))})]\n\n\n    (when (xhr-await top)\n      (pln :top-waited!!!!!!!!!)\n      (when (xhr-response top)\n        (pln :top-response!!!!!!!!!!!!! (xhr-status-key top))\n        (is (= 200 (xhr-status-key top)))\n        (is (= 3 (count (md-kids top))))\n        (doseq [ae (md-kids top)]\n          (do\n            (pln :ae (xhr-status-key ae) (:name @ae) (:ae @ae))\n            (is (= 200 (xhr-status-key ae))))))\n      (println :fini!!!!!!!!))))&quot;, :offset 2527, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(def ae-brand\n  \&quot;https://api.fda.gov/drug/event.json?search=patient.drug.openfda.brand_name:~a&amp;limit=~a\&quot;)&quot;, :offset 105, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(deftest fda-adverse-lite\n  ;; for 3 AEs\n  ;;   for each drug taken by patient\n  ;;     get the labeling\n  ;;     get up to 3 recall notices from the manufacturer\n  (let [top (make-xhr #_ ae-adderall (cl-format ae-brand \&quot;adderall\&quot; 1)\n              {:send? true\n               :kids  (c? #_(when-let [aes (:results (xhr-selection me))]\n                              (println :bingo-patients!)\n                              (doseq [p (map :patient aes)]\n                                (println :pkeys (keys (:openfda (first (:drug p)))))\n                                ;(println :drug-ct (map #(first (:product-ndc %)) (:drug p)))\n                                )\n                              nil)\n\n                        (when-let [aes (:results (xhr-selection me))]\n                          (pln :got-aes!!!! (count aes))\n                          (the-kids\n                            (for [ae aes]\n                              (do (pln :ae!!!!!!!)\n\n                                  (make ::md/family\n                                    :name :adverse-event\n                                    :ae (dissoc ae :patient)\n                                    :patient (dissoc (:patient ae) :drug)\n                                    :kids (c? (the-kids\n                                                (for [drug (:drug (:patient ae))\n                                                      :let [ndc (get-in drug [:openfda :product_ndc])]]\n                                                  (make-xhr (cl-format drug-label ndc)\n                                                    {:send? true\n                                                     :dbg   ndc})\n                                                  #_(make-xhr-group\n                                                      :name :patient-drug\n                                                      :kids (C? (the-kids\n                                                                  (make-xhr (cl-format ae-label ndc))\n                                                                  (make-xhr (cl-format ae-recalls ndc))))))))))))))})]\n\n\n    (when (xhr-await top)\n      (pln :top-waited!!!!!!!!!)\n      (when (xhr-response top)\n        (pln :top-response!!!!!!!!!!!!! (xhr-status-key top))\n        (is (= 200 (xhr-status-key top)))\n        (is (= 3 (count (md-kids top))))\n        (doseq [ae (md-kids top)]\n          (do\n            (pln :ae (xhr-status-key ae) (:name @ae) (:ae @ae))\n            (is (= 200 (xhr-status-key ae))))))\n      (println :fini!!!!!!!!))))&quot;, :offset 2527, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(cl-format ae-brand \&quot;adderall\&quot; 1)&quot;, :offset 33, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(cl-format ae-ndc \&quot;adderall\&quot; 1)&quot;, :offset 31, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(cl-format ae-ndc \&quot;1234\&quot; 1)&quot;, :offset 27, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(cl-format \&quot;w ~a tf ~a\&quot; \&quot;1234\&quot; 1)&quot;, :offset 33, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(cl-format nil \&quot;w ~a tf ~a\&quot; \&quot;1234\&quot; 1)&quot;, :offset 37, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(deftest fda-adverse-lite\n  ;; for 3 AEs\n  ;;   for each drug taken by patient\n  ;;     get the labeling\n  ;;     get up to 3 recall notices from the manufacturer\n  (let [top (make-xhr #_ ae-adderall (cl-format nil ae-brand \&quot;adderall\&quot; 1)\n              {:send? true\n               :kids  (c? #_(when-let [aes (:results (xhr-selection me))]\n                              (println :bingo-patients!)\n                              (doseq [p (map :patient aes)]\n                                (println :pkeys (keys (:openfda (first (:drug p)))))\n                                ;(println :drug-ct (map #(first (:product-ndc %)) (:drug p)))\n                                )\n                              nil)\n\n                        (when-let [aes (:results (xhr-selection me))]\n                          (pln :got-aes!!!! (count aes))\n                          (the-kids\n                            (for [ae aes]\n                              (do (pln :ae!!!!!!!)\n\n                                  (make ::md/family\n                                    :name :adverse-event\n                                    :ae (dissoc ae :patient)\n                                    :patient (dissoc (:patient ae) :drug)\n                                    :kids (c? (the-kids\n                                                (for [drug (:drug (:patient ae))\n                                                      :let [ndc (get-in drug [:openfda :product_ndc])]]\n                                                  (make-xhr (cl-format nil drug-label ndc)\n                                                    {:send? true\n                                                     :dbg   ndc})\n                                                  #_(make-xhr-group\n                                                      :name :patient-drug\n                                                      :kids (C? (the-kids\n                                                                  (make-xhr (cl-format ae-label ndc))\n                                                                  (make-xhr (cl-format ae-recalls ndc))))))))))))))})]\n\n\n    (when (xhr-await top)\n      (pln :top-waited!!!!!!!!!)\n      (when (xhr-response top)\n        (pln :top-response!!!!!!!!!!!!! (xhr-status-key top))\n        (is (= 200 (xhr-status-key top)))\n        (is (= 3 (count (md-kids top))))\n        (doseq [ae (md-kids top)]\n          (do\n            (pln :ae (xhr-status-key ae) (:name @ae) (:ae @ae))\n            (is (= 200 (xhr-status-key ae))))))\n      (println :fini!!!!!!!!))))&quot;, :offset 2535, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(deftest fda-adverse-lite\n  ;; for 3 AEs\n  ;;   for each drug taken by patient\n  ;;     get the labeling\n  ;;     get up to 3 recall notices from the manufacturer\n  (let [top (make-xhr #_ ae-adderall (cl-format nil ae-brand \&quot;adderall\&quot; 1)\n              {:send? true\n               :kids  (c? #_(when-let [aes (:results (xhr-selection me))]\n                              (println :bingo-patients!)\n                              (doseq [p (map :patient aes)]\n                                (println :pkeys (keys (:openfda (first (:drug p)))))\n                                ;(println :drug-ct (map #(first (:product-ndc %)) (:drug p)))\n                                )\n                              nil)\n\n                        (when-let [aes (:results (xhr-selection me))]\n                          (pln :got-aes!!!! (count aes))\n                          (the-kids\n                            (for [ae aes]\n                              (do (pln :ae!!!!!!!)\n\n                                  (make ::md/family\n                                    :name :adverse-event\n                                    :ae (dissoc ae :patient)\n                                    :patient (dissoc (:patient ae) :drug)\n                                    :kids (c? (the-kids\n                                                (for [drug (take 1 (:drug (:patient ae)))\n                                                      :let [ndc (get-in drug [:openfda :product_ndc])]]\n                                                  (make-xhr (cl-format nil drug-label ndc)\n                                                    {:send? true\n                                                     :dbg   ndc})\n                                                  #_(make-xhr-group\n                                                      :name :patient-drug\n                                                      :kids (C? (the-kids\n                                                                  (make-xhr (cl-format ae-label ndc))\n                                                                  (make-xhr (cl-format ae-recalls ndc))))))))))))))})]\n\n\n    (when (xhr-await top)\n      (pln :top-waited!!!!!!!!!)\n      (when (xhr-response top)\n        (pln :top-response!!!!!!!!!!!!! (xhr-status-key top))\n        (is (= 200 (xhr-status-key top)))\n        (is (= 3 (count (md-kids top))))\n        (doseq [ae (md-kids top)]\n          (do\n            (pln :ae (xhr-status-key ae) (:name @ae) (:ae @ae))\n            (is (= 200 (xhr-status-key ae))))))\n      (println :fini!!!!!!!!))))&quot;, :offset 2544, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(defn xhr-dump [xhr]\n  (case (:name @xhr)\n    :patient-drug (cpr :patient-drug (:dbg @xhr)\n                       :status (xhr-status-key info)\n                       :drug-label-warning (first (:warnings (first (:results (md-get xhr :selection))))))\n    (cpr :xhr-dump-unknown (:name @xhr) (:dbg @xhr))))&quot;, :offset 305, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(defn xhr-dump [xhr]\n  (case (:name @xhr)\n    :patient-drug (cpr :patient-drug (:dbg @xhr)\n                       :status (xhr-status-key xhr)\n                       :drug-label-warning (first (:warnings (first (:results (md-get xhr :selection))))))\n    (cpr :xhr-dump-unknown (:name @xhr) (:dbg @xhr))))&quot;, :offset 304, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(declare xhr-dump)&quot;, :offset 18, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(defn xhr-dump \n  ([xhr] (xhr-dump \&quot;untagged\&quot; xhr))\n  ([tag xhr] (case (:name @xhr)\n               :patient-drug (cpr (:name @xhr) (:dbg @xhr)\n                                  :status (xhr-status-key xhr)\n                                  :drug-label-warning (first (:warnings (first (:results (md-get xhr :selection))))))\n               (cpr :xhr-dump-unknown (:name @xhr) (:dbg @xhr)))))&quot;, :offset 390, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(defn xhr-dump\n  ([xhr] (xhr-dump \&quot;untagged\&quot; xhr))\n  ([tag xhr] (case (:name @xhr)\n               :drug-label (cpr (:name @xhr) (:dbg @xhr)\n                                  :status (xhr-status-key xhr)\n                                  :drug-label-warning (first (:warnings (first (:results (md-get xhr :selection))))))\n               (cpr :xhr-dump-unknown (:name @xhr) (:dbg @xhr)))))&quot;, :offset 387, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(deftest fda-adverse-lite\n  ;; for 3 AEs\n  ;;   for each drug taken by patient\n  ;;     get the labeling\n  ;;     get up to 3 recall notices from the manufacturer\n  (let [ae-count 1\n        top (make-xhr (cl-format nil ae-brand \&quot;adderall\&quot; ae-count)\n              {:send? true\n               :kids  (c? (when-let [aes (:results (xhr-selection me))]\n                            (the-kids\n                              (for [ae aes]\n                                (make ::md/family\n                                  :name :adverse-event\n                                  :ae (dissoc ae :patient)\n                                  :patient (dissoc (:patient ae) :drug)\n                                  :kids (c? (the-kids\n                                              (for [drug (take 1 (:drug (:patient ae)))\n                                                    :let [ndc (first (get-in drug [:openfda :product_ndc]))]]\n                                                (do (println :drug-fda (:openfda drug))\n                                                    (println :mfr (keys (:openfda drug)))\n                                                    (make ::md/family\n                                                      :name :patient-drug\n                                                      :ndc ndc\n                                                      :kids (c? (the-kids\n                                                                  (make-xhr (cl-format nil drug-label ndc)\n                                                                    {:name  :drug-label\n                                                                     :send? true\n                                                                     :dbg   ndc})\n                                                                  #_(make-xhr (cl-format nil ae-recalls mfr-name))))))))))))))})]\n\n\n    (when (xhr-await top)\n      (pln :top-waited!!!!!!!!!)\n      (when (xhr-response top)\n        (pln :top-response!!!!!!!!!!!!! (xhr-status-key top))\n        (is (= 200 (xhr-status-key top)))\n        (is (= ae-count (count (md-kids top))))\n        (doseq [ae (md-kids top)]\n          (pln :ae!!!! (md-get ae :ae))\n          (pln :patient (md-get ae :patient))\n          (doseq [drug (md-kids ae)]\n            (pln :drug! (:name @drug) (:ndc @drug))\n            (doseq [info (md-kids drug)]\n              (xhr-dump \&quot;drug-info\&quot; info)\n              (is (= 200 (xhr-status-key info)))))))\n      (println :fini!!!!!!!!))))&quot;, :offset 2486, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(defn make [&amp; arg-list]\n  (cond\n    (odd? (count arg-list)) (apply make :type arg-list)\n    :else\n    (#?(:clj dosync :cljs do)\n     ;;(println (str :md-making (nth iargs 1)))\n      \n     (let [iargs (apply hash-map arg-list)\n           me (#?(:clj ref :cljs atom)\n               (merge {:par *par*}\n                      (-&gt;&gt; arg-list\n                           (partition 2)\n                           (filter (fn [[slot v]]\n                                     (not (= :type slot))))\n                           (map (fn [[k v]]\n                                  (vector k (if (c-ref? v)\n                                              unbound\n                                              v))))\n                           (into {})))\n               :meta (merge\n                       {:state :nascent}\n                       (select-keys iargs [:type])))]\n       (assert (meta me))\n        #_(when-not (:par @me)\n          (println :no-par!!!! me))\n       (rmap-meta-setf\n        [:cz me]\n        (-&gt;&gt; arg-list\n             (partition 2)\n             (filter (fn [[slot v]]\n                       (md-install-cell me slot v)))\n             (map vec)\n             (into {})))\n\n       (with-integrity (:awaken me)\n        (md-awaken me)\n        #_ (println :md-awaken-complete))\n       me))))&quot;, :offset 1292, :ns &quot;tiltontec.model.core&quot;} {:command &quot;(defn xhr-send [xhr]\n  (let [uri (md-get xhr :uri)]\n    (cpr :xhr-send-sending uri)\n\n    #?(:clj (client/get uri\n              {:async? true}\n              (fn [response]\n                (cpr :xhr-response!!! (:id @xhr) (:status response) uri)\n                (if (mdead? xhr)\n                  (do (cpr :ignoring-response-to-dead-XHR!!! uri (meta xhr)))\n                  (do ;; (cpr :hitting-with-cc *within-integrity*)\n                      (with-cc :xhr-handler-sets-responded\n\n                        ;(cpr :xhr-handler-body)\n                        ;(cpr :xhr-handler-sets-responded @xhr xhr)\n                        ;; (pprint (parse-string (:body response) true))\n                        (md-reset! xhr :response {:status (:status response)\n                                                  :body   (parse-string (:body response) true)})))))\n              (fn [exception]\n                (let [edata (:data (bean exception))]\n\n                  (cpr :xhr-exception!!! (:id @xhr) uri (:status edata) (parse-string (:body edata) true))\n                  (pprint (dissoc (bean exception) :stackTrace))\n                  (when-not (mdead? xhr)\n                    (with-cc :xhr-handler-sets-error\n                      (cpr :xhr-handler-sets-error)\n                      (md-reset! xhr :response {:status (:status edata)\n                                                :body   (parse-string (:body edata) true)})))))))))&quot;, :offset 1424, :ns &quot;tiltontec.xhr.core&quot;} {:command &quot;(deftest fda-adverse-lite\n  ;; for 3 AEs\n  ;;   for each drug taken by patient\n  ;;     get the labeling\n  ;;     get up to 3 recall notices from the manufacturer\n  (let [ae-count 1\n        top (make-xhr (cl-format nil ae-brand \&quot;adderall\&quot; ae-count)\n              {:send? true\n               :kids  (c? (when-let [aes (:results (xhr-selection me))]\n                            (the-kids\n                              (for [ae aes]\n                                (make ::md/family\n                                  :name :adverse-event\n                                  :ae (dissoc ae :patient)\n                                  :patient (dissoc (:patient ae) :drug)\n                                  :kids (c? (the-kids\n                                              (for [drug (take 1 (:drug (:patient ae)))\n                                                    :let [ndc (first (get-in drug [:openfda :product_ndc]))\n                                                          mfr-name (get-in drug [:openfda :manufacturer_name])]]\n                                                (do (println :drug-fda (:openfda drug))\n                                                    (println :mfr mfr-name)\n                                                    (make ::md/family\n                                                      :name :patient-drug\n                                                      :ndc ndc\n                                                      :kids (c? (the-kids\n                                                                  (make-xhr (cl-format nil drug-label ndc)\n                                                                    {:name  :drug-label\n                                                                     :send? true\n                                                                     :dbg   ndc})\n                                                                  (make-xhr (cl-format nil mfr-recalls mfr-name 1)\n                                                                    {:name  :drug-label\n                                                                     :send? true\n                                                                     :dbg   ndc})))))))))))))})]\n\n\n    (when (xhr-await top)\n      (when (xhr-response top)\n        (pln :top-response!!!!!!!!!!!!! (xhr-status-key top))\n        (is (= 200 (xhr-status-key top)))\n        (is (= ae-count (count (md-kids top))))\n        (doseq [ae (md-kids top)]\n          (pln :ae!!!! (md-get ae :ae))\n          (pln :patient (md-get ae :patient))\n          (doseq [drug (md-kids ae)]\n            (pln :drug! (:name @drug) (:ndc @drug))\n            (doseq [info (md-kids drug)]\n              (xhr-dump \&quot;drug-info\&quot; info)\n              (is (= 200 (xhr-status-key info)))))))\n      (println :fini!!!!!!!!))))&quot;, :offset 2801, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(def mfr-recalls\n  \&quot;https://api.fda.gov/drug/enforcement.json?search=recalling_firm:~a&amp;limit=~a\&quot;)&quot;, :offset 97, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(deftest fda-adverse-lite\n  ;; for 3 AEs\n  ;;   for each drug taken by patient\n  ;;     get the labeling\n  ;;     get up to 3 recall notices from the manufacturer\n  (let [ae-count 1\n        top (make-xhr (cl-format nil ae-brand \&quot;adderall\&quot; ae-count)\n              {:send? true\n               :kids  (c? (when-let [aes (:results (xhr-selection me))]\n                            (the-kids\n                              (for [ae aes]\n                                (make ::md/family\n                                  :name :adverse-event\n                                  :ae (dissoc ae :patient)\n                                  :patient (dissoc (:patient ae) :drug)\n                                  :kids (c? (the-kids\n                                              (for [drug (take 1 (:drug (:patient ae)))\n                                                    :let [ndc (first (get-in drug [:openfda :product_ndc]))\n                                                          mfr-name (first (get-in drug [:openfda :manufacturer_name]))]]\n                                                (do (println :drug-fda (:openfda drug))\n                                                    (println :mfr mfr-name)\n                                                    (make ::md/family\n                                                      :name :patient-drug\n                                                      :ndc ndc\n                                                      :kids (c? (the-kids\n                                                                  (make-xhr (cl-format nil drug-label ndc)\n                                                                    {:name  :drug-label\n                                                                     :send? true\n                                                                     :dbg   ndc})\n                                                                  (make-xhr (cl-format nil mfr-recalls mfr-name 1)\n                                                                    {:name  :drug-label\n                                                                     :send? true\n                                                                     :dbg   ndc})))))))))))))})]\n\n\n    (when (xhr-await top)\n      (when (xhr-response top)\n        (pln :top-response!!!!!!!!!!!!! (xhr-status-key top))\n        (is (= 200 (xhr-status-key top)))\n        (is (= ae-count (count (md-kids top))))\n        (doseq [ae (md-kids top)]\n          (pln :ae!!!! (md-get ae :ae))\n          (pln :patient (md-get ae :patient))\n          (doseq [drug (md-kids ae)]\n            (pln :drug! (:name @drug) (:ndc @drug))\n            (doseq [info (md-kids drug)]\n              (xhr-dump \&quot;drug-info\&quot; info)\n              (is (= 200 (xhr-status-key info)))))))\n      (println :fini!!!!!!!!))))&quot;, :offset 2809, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(defn xhr-dump\n  ([xhr] (xhr-dump \&quot;untagged\&quot; xhr))\n  ([tag xhr] (case (:name @xhr)\n               :drug-label (cpr (:name @xhr) (:dbg @xhr)\n                                :status (xhr-status-key xhr)\n                                :drug-label-warning (first (:warnings (first (:results (md-get xhr :selection))))))\n               :mfr-recall (cpr (:name @xhr) (:dbg @xhr)\n                                :status (xhr-status-key xhr)\n                                :sel (first (:results (md-get xhr :selection))))\n               (cpr :xhr-dump-unknown (:name @xhr) (:dbg @xhr)))))&quot;, :offset 582, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(defn xhr-dump\n  ([xhr] (xhr-dump \&quot;untagged\&quot; xhr))\n  ([tag xhr] (case (:name @xhr)\n               :drug-label (cpr (:name @xhr) (:dbg @xhr)\n                                :status (xhr-status-key xhr)\n                                :drug-label-warning (first (:warnings (first (:results (md-get xhr :selection))))))\n               :mfr-recall (cpr (:name @xhr) (:dbg @xhr)\n                                :status (xhr-status-key xhr)\n                                :sel (select-keys (first (:results (md-get xhr :selection)))\n                                                  [:state :reason_for_recall]))\n               (cpr :xhr-dump-unknown (:name @xhr) (:dbg @xhr)))))&quot;, :offset 674, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(defn xhr-dump\n  ([xhr] (xhr-dump \&quot;untagged\&quot; xhr))\n  ([tag xhr] (case (:name @xhr)\n               :drug-label (cpr (:name @xhr) (:dbg @xhr)\n                                :status (xhr-status-key xhr)\n                                :drug-label-warning (first (:warnings (first (:results (md-get xhr :selection))))))\n               :mfr-recall (cpr (:name @xhr) (:dbg @xhr)\n                                :status (xhr-status-key xhr)\n                                (first (:results (md-get xhr :selection)))\n                                :sel (select-keys (first (:results (md-get xhr :selection)))\n                                                  [:state :reason_for_recall]))\n               (cpr :xhr-dump-unknown (:name @xhr) (:dbg @xhr)))))&quot;, :offset 749, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(defmacro getxhr [id uri &amp; child-xhrs]\n  `(make-xhr ~uri\n     {:send? true\n      :name ~id\n      :kids  (c? ~@child-xhrs)}))&quot;, :offset 124, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(deftest fda-adverse-lite\n  ;; for 3 AEs\n  ;;   for each drug taken by patient\n  ;;     get the labeling\n  ;;     get up to 3 recall notices from the manufacturer\n  (let [ae-count 5\n        top (make-xhr (cl-format nil ae-brand \&quot;adderall\&quot; ae-count)\n              {:send? true\n               :name :brand-aes\n               :kids  (c? (when-let [aes (:results (xhr-selection me))]\n                            (the-kids\n                              (for [ae aes]\n                                (make ::md/family\n                                  :name :adverse-event\n                                  :ae (dissoc ae :patient)\n                                  :patient (dissoc (:patient ae) :drug)\n                                  :kids (c? (the-kids\n                                              (for [drug (take 5 (:drug (:patient ae)))\n                                                    :let [ndc (first (get-in drug [:openfda :product_ndc]))\n                                                          mfr-name (first (get-in drug [:openfda :manufacturer_name]))]]\n                                                (do (println :drug-fda (:openfda drug))\n                                                    (println :mfr mfr-name)\n                                                    (make ::md/family\n                                                      :name :patient-drug\n                                                      :ndc ndc\n                                                      :kids (c? (the-kids\n                                                                  (make-xhr (cl-format nil drug-label ndc)\n                                                                    {:name  :drug-label\n                                                                     :send? true\n                                                                     :dbg   ndc})\n                                                                  (make-xhr (cl-format nil mfr-recalls mfr-name 1)\n                                                                    {:name  :mfr-recall\n                                                                     :send? true\n                                                                     :dbg   ndc})))))))))))))})]\n\n\n    (when (xhr-await top)\n      (when (xhr-response top)\n        (pln :top-response!!!!!!!!!!!!! (xhr-status-key top))\n        (is (= 200 (xhr-status-key top)))\n        (is (= ae-count (count (md-kids top))))\n        (doseq [ae (md-kids top)]\n          (pln :ae!!!! (md-get ae :ae))\n          (pln :patient (md-get ae :patient))\n          (doseq [drug (md-kids ae)]\n            (pln :drug! (:name @drug) (:ndc @drug))\n            (doseq [info (md-kids drug)]\n              (xhr-dump \&quot;drug-info\&quot; info)\n              (is (= 200 (xhr-status-key info)))))))\n      (println :fini!!!!!!!!))))&quot;, :offset 2841, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(deftest fda-adverse-lite\n  ;; for 3 AEs\n  ;;   for each drug taken by patient\n  ;;     get the labeling\n  ;;     get up to 3 recall notices from the manufacturer\n  (let [ae-count 1\n        top (make-xhr (cl-format nil ae-brand \&quot;adderall\&quot; ae-count)\n              {:send? true\n               :name :brand-aes\n               :kids  (c? (when-let [aes (:results (xhr-selection me))]\n                            (the-kids\n                              (for [ae aes]\n                                (make ::md/family\n                                  :name :adverse-event\n                                  :ae (dissoc ae :patient)\n                                  :patient (dissoc (:patient ae) :drug)\n                                  :kids (c? (the-kids\n                                              (for [drug (take 1 (:drug (:patient ae)))\n                                                    :let [ndc (first (get-in drug [:openfda :product_ndc]))\n                                                          mfr-name (first (get-in drug [:openfda :manufacturer_name]))]]\n                                                (do (println :drug-fda (:openfda drug))\n                                                    (println :mfr mfr-name)\n                                                    (make ::md/family\n                                                      :name :patient-drug\n                                                      :ndc ndc\n                                                      :kids (c? (the-kids\n                                                                  (make-xhr (cl-format nil drug-label ndc)\n                                                                    {:name  :drug-label\n                                                                     :send? true\n                                                                     :dbg   ndc})\n                                                                  (make-xhr (cl-format nil mfr-recalls mfr-name 1)\n                                                                    {:name  :mfr-recall\n                                                                     :send? true\n                                                                     :dbg   ndc})))))))))))))})]\n\n\n    (when (xhr-await top)\n      (when (xhr-response top)\n        (pln :top-response!!!!!!!!!!!!! (xhr-status-key top))\n        (is (= 200 (xhr-status-key top)))\n        (is (= ae-count (count (md-kids top))))\n        (doseq [ae (md-kids top)]\n          (pln :ae!!!! (md-get ae :ae))\n          (pln :patient (md-get ae :patient))\n          (doseq [drug (md-kids ae)]\n            (pln :drug! (:name @drug) (:ndc @drug))\n            (doseq [info (md-kids drug)]\n              (xhr-dump \&quot;drug-info\&quot; info)\n              (is (= 200 (xhr-status-key info)))))))\n      (println :fini!!!!!!!!))))&quot;, :offset 2841, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(deftest recall-fail\n  (let [xhr (xhr-await\n              (send-xhr \&quot;https://api.fda.gov/drug/enforcement.json?search=recalling_firm:Teva Women's Health, Inc.&amp;limit=1\&quot;))]\n    (println :Teva-fail (xhr-status-key xhr))))&quot;, :offset 218, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(deftest recall-fail\n  (let [xhr (xhr-await\n              (send-xhr \&quot;https://api.fda.gov/drug/enforcement.json?search=recalling_firm:Teva&amp;limit=1\&quot;))]\n    (println :Teva (xhr-status-key xhr)\n             (xhr-selection xhr))))&quot;, :offset 225, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(deftest recall-fail\n  (let [xhr (xhr-await\n              (send-xhr \&quot;https://api.fda.gov/drug/enforcement.json?search=recalling_firm:Teva&amp;limit=1\&quot;))]\n    (println :Teva (xhr-status-key xhr)\n             (:results (xhr-selection xhr)))))&quot;, :offset 236, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(ns tiltontec.xhr.core-test\n  (:require\n    [clojure.test :refer :all]\n    [clojure.string :as str]\n    [clojure.set :as set]\n    [#?(:cljs cljs.pprint :clj clojure.pprint) :refer [pprint cl-format]]\n    [tiltontec.util.core :refer [pln xor now *plnk-keys*]]\n    [tiltontec.cell.evaluate :refer [c-get c-awaken not-to-be]]\n\n    #?(:clj\n    [tiltontec.cell.base :refer :all]\n       :cljs [tiltontec.cell.base\n              :refer-macros [without-c-dependency]\n              :refer [cells-init +pulse+ unbound cpr]])\n    [tiltontec.cell.integrity :refer [*dp-log*]]\n    [tiltontec.cell.core :refer :all]\n\n    #?(:clj\n    [tiltontec.model.core :refer :all]\n       :cljs [tiltontec.model.core\n              :refer-macros [the-kids mdv!]\n              :refer [md-get fasc fm! make md-reset! backdoor-reset!\n                      mx-par]\n              :as md])\n\n    [tiltontec.xhr.core\n     :refer [make-xhr send-xhr xhr-response xhr-send xhr-await xhr-status\n             xhr-status-key xhr-resolved xhr-error? xhrfo synaptic-xhr\n             xhr-selection]]\n\n    #?(:clj\n    [tiltontec.cell.synapse :refer :all]\n       :cljs [tiltontec.cell.synapse\n              :refer-macros [with-synapse]\n              :refer []])\n\n    #?(:clj\n    [tiltontec.cell.observer :refer [fn-obs]]\n       :cljs [tiltontec.cell.observer :refer-macros [fn-obs]])\n\n    #?(:clj\n    [tiltontec.tag.gen :refer :all]\n       :cljs [tiltontec.tag.gen :refer [evt-tag target-value] :refer-macros [h1 input div]])\n\n    [cheshire.core :refer :all]\n    \n    #?(:clj\n    [clj-http.util :as httpu]\n       :cljs [cljs-http.util :as httpu])\n\n    #?(:clj\n    [clj-http.client :as client]\n       :cljs [cljs-http.client :as client])))&quot;, :offset 1690, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(deftest recall-fail\n  (let [xhr (xhr-await\n              (send-xhr (httpu/url-encode\n                          \&quot;https://api.fda.gov/drug/enforcement.json?search=recalling_firm:Teva Woman%27s Health&amp;limit=1\&quot;)))]\n    (println :Teva (xhr-status-key xhr)\n             (:recalling_firm (first (:results (xhr-selection xhr)))))))&quot;, :offset 324, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(httpu/url-encode \&quot;https://api.fda.gov/drug/enforcement.json?search=recalling_firm:Teva Woman%27s Health&amp;limit=1\&quot;)&quot;, :offset 114, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(str/replace \&quot;Hi's mom\&quot; #\&quot;'\&quot; \&quot;\&quot;)&quot;, :offset 32, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(some #{200} [200 400])&quot;, :offset 23, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(defn xhr-send [xhr]\n  (let [uri (md-get xhr :uri)]\n    (cpr :xhr-send-sending uri)\n\n    #?(:clj (client/get uri\n              {:async? true}\n              (fn [response]\n                (cpr :xhr-response!!! (:id @xhr) (:status response) uri)\n                (if (mdead? xhr)\n                  (do (cpr :ignoring-response-to-dead-XHR!!! uri (meta xhr)))\n                  (do ;; (cpr :hitting-with-cc *within-integrity*)\n                      (with-cc :xhr-handler-sets-responded\n\n                        ;(cpr :xhr-handler-body)\n                        ;(cpr :xhr-handler-sets-responded @xhr xhr)\n                        ;; (pprint (parse-string (:body response) true))\n                        (md-reset! xhr :response {:status (:status response)\n                                                  :body   (parse-string (:body response) true)})))))\n              (fn [exception]\n                (let [edata (:data (bean exception))]\n\n                  (cpr :xhr-exception!!! (:id @xhr) uri (:status edata) (parse-string (:body edata) true))\n                  ;; (pprint (dissoc (bean exception) :stackTrace))\n                  (when-not (mdead? xhr)\n                    (with-cc :xhr-handler-sets-error\n                      ;; (cpr :xhr-handler-sets-error)\n                      (md-reset! xhr :response {:status (:status edata)\n                                                :body   (parse-string (:body edata) true)})))))))))&quot;, :offset 1430, :ns &quot;tiltontec.xhr.core&quot;} {:command &quot;(defn xhr-send [xhr]\n  (let [uri (md-get xhr :uri)]\n    ;;(cpr :xhr-send-sending uri)\n\n    #?(:clj (client/get uri\n              {:async? true}\n              (fn [response]\n                ;;(cpr :xhr-response!!! (:id @xhr) (:status response) uri)\n                (if (mdead? xhr)\n                  (do (cpr :ignoring-response-to-dead-XHR!!! uri (meta xhr)))\n                  (do ;; (cpr :hitting-with-cc *within-integrity*)\n                      (with-cc :xhr-handler-sets-responded\n\n                        ;(cpr :xhr-handler-body)\n                        ;(cpr :xhr-handler-sets-responded @xhr xhr)\n                        ;; (pprint (parse-string (:body response) true))\n                        (md-reset! xhr :response {:status (:status response)\n                                                  :body   (parse-string (:body response) true)})))))\n              (fn [exception]\n                (let [edata (:data (bean exception))]\n\n                  (cpr :xhr-exception!!! (:id @xhr) uri (:status edata) (parse-string (:body edata) true))\n                  ;; (pprint (dissoc (bean exception) :stackTrace))\n                  (when-not (mdead? xhr)\n                    (with-cc :xhr-handler-sets-error\n                      ;; (cpr :xhr-handler-sets-error)\n                      (md-reset! xhr :response {:status (:status edata)\n                                                :body   (parse-string (:body edata) true)})))))))))&quot;, :offset 1434, :ns &quot;tiltontec.xhr.core&quot;} {:command &quot;(deftest fda-adverse-lite\n  ;; for 3 AEs\n  ;;   for each drug taken by patient\n  ;;     get the labeling\n  ;;     get up to 3 recall notices from the manufacturer\n  (let [ae-count 5\n        brand \&quot;adderall\&quot;\n        top (make-xhr (cl-format nil ae-brand brand ae-count)\n              {:send? true\n               :name  :brand-adv-eventss\n               :brand brand\n               :kids  (c? (when-let [aes (:results (xhr-selection me))]\n                            (the-kids\n                              (for [ae aes]\n                                (make ::md/family\n                                  :name :adverse-event\n                                  :ae (dissoc ae :patient)\n                                  :patient (dissoc (:patient ae) :drug)\n                                  :kids (c? (the-kids\n                                              (for [drug (take 1 (:drug (:patient ae)))\n                                                    :let [ndc (first (get-in drug [:openfda :product_ndc]))\n                                                          mfr-name (first (get-in drug [:openfda :manufacturer_name]))]]\n                                                (do ;; (println :drug-fda (:openfda drug))\n                                                    (make ::md/family\n                                                      :name :patient-drug\n                                                      :ndc ndc\n                                                      :kids (c? (the-kids\n                                                                  (make-xhr (cl-format nil drug-label ndc)\n                                                                    {:name  :drug-label\n                                                                     :send? true\n                                                                     :dbg   ndc})\n                                                                  (make-xhr (cl-format nil mfr-recalls\n                                                                                       (str/replace mfr-name #\&quot;'\&quot; \&quot;\&quot;)\n                                                                                       1)\n                                                                    {:name  :mfr-recall\n                                                                     :send? true\n                                                                     :dbg   mfr-name})))))))))))))})]\n\n\n    (when (xhr-await top)\n      (is (= 200 (xhr-status-key top)))\n      (is (= ae-count (count (md-kids top))))\n      (doseq [ae (md-kids top)]\n        (pln :ae!!!! (md-get ae :ae))\n        (pln :patient (md-get ae :patient))\n        (doseq [drug (md-kids ae)]\n          (pln :drug! (:name @drug) (:ndc @drug))\n          (doseq [info (md-kids drug)]\n            (xhr-dump \&quot;drug-info\&quot; info)\n            (is (some #{(xhr-status-key info)} [200 400])))))\n\n      (println :fini!!!!!!!!))))&quot;, :offset 2925, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(defn xhr-to-map [xhr]\n  {:type (type xhr)})&quot;, :offset 44, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(declare xhr-dump xhr-to-map)&quot;, :offset 29, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(defn xhr-to-map [xhr]\n  {:type (type xhr)\n   :keys (keys @xhr)})&quot;, :offset 65, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(defn xhr-to-map [xhr]\n  (case (type xhr)\n    :tiltontec.xhr.core/xhr (dissoc @xhr :response :select :selection))\n  )&quot;, :offset 117, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(defn xhr-to-map [xhr]\n  (case (type xhr)\n    :tiltontec.xhr.core/xhr (keys xhr) #_ (dissoc @xhr :response :select :selection))\n  )&quot;, :offset 131, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(ns tiltontec.xhr.core-test\n  (:require\n    [clojure.test :refer :all]\n    [clojure.string :as str]\n    [clojure.set :as set]\n    [#?(:cljs cljs.pprint :clj clojure.pprint) :refer [pprint cl-format]]\n    [tiltontec.util.core :refer [pln xor now *plnk-keys*]]\n    [tiltontec.cell.evaluate :refer [c-get c-awaken not-to-be]]\n\n    #?(:clj\n    [tiltontec.cell.base :refer :all]\n       :cljs [tiltontec.cell.base\n              :refer-macros [without-c-dependency]\n              :refer [cells-init +pulse+ unbound cpr]])\n    [tiltontec.cell.integrity :refer [*dp-log*]]\n    [tiltontec.cell.core :refer :all]\n\n    #?(:clj\n    [tiltontec.model.core :refer :all :as md]\n       :cljs [tiltontec.model.core\n              :refer-macros [the-kids mdv!]\n              :refer [md-get fasc fm! make md-reset! backdoor-reset!\n                      mx-par]\n              :as md])\n\n    [tiltontec.xhr.core\n     :refer [make-xhr send-xhr xhr-response xhr-send xhr-await xhr-status\n             xhr-status-key xhr-resolved xhr-error? xhrfo synaptic-xhr\n             xhr-selection]]\n\n    #?(:clj\n    [tiltontec.cell.synapse :refer :all]\n       :cljs [tiltontec.cell.synapse\n              :refer-macros [with-synapse]\n              :refer []])\n\n    #?(:clj\n    [tiltontec.cell.observer :refer [fn-obs]]\n       :cljs [tiltontec.cell.observer :refer-macros [fn-obs]])\n\n    #?(:clj\n    [tiltontec.tag.gen :refer :all]\n       :cljs [tiltontec.tag.gen :refer [evt-tag target-value] :refer-macros [h1 input div]])\n\n    [cheshire.core :refer :all]\n\n    #?(:clj\n    [clj-http.util :as httpu]\n       :cljs [cljs-http.util :as httpu])\n\n    #?(:clj\n    [clj-http.client :as client]\n       :cljs [cljs-http.client :as client])))&quot;, :offset 1693, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(defn xhr-to-map [xhr]\n  (case (type xhr)\n    :tiltontec.xhr.core/xhr (keys @xhr) #_ (dissoc @xhr :response :select :selection))\n  )&quot;, :offset 132, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(deftest fda-adverse-lite\n  ;; for 3 AEs\n  ;;   for each drug taken by patient\n  ;;     get the labeling\n  ;;     get up to 3 recall notices from the manufacturer\n  (let [ae-count 5\n        brand \&quot;adderall\&quot;\n        top (make-xhr (cl-format nil ae-brand brand ae-count)\n              {:send? true\n               :name  :brand-adv-events\n               :brand brand\n               :kids  (c? (when-let [aes (:results (xhr-selection me))]\n                            (the-kids\n                              (for [ae aes]\n                                (make ::md/family\n                                  :name :adverse-event\n                                  :ae (dissoc ae :patient)\n                                  :patient (dissoc (:patient ae) :drug)\n                                  :kids (c? (the-kids\n                                              (for [drug (take 1 (:drug (:patient ae)))\n                                                    :let [ndc (first (get-in drug [:openfda :product_ndc]))\n                                                          mfr-name (first (get-in drug [:openfda :manufacturer_name]))]]\n                                                (do ;; (println :drug-fda (:openfda drug))\n                                                    (make ::md/family\n                                                      :name :patient-drug\n                                                      :ndc ndc\n                                                      :kids (c? (the-kids\n                                                                  (make-xhr (cl-format nil drug-label ndc)\n                                                                    {:name  :drug-label\n                                                                     :send? true\n                                                                     :dbg   ndc})\n                                                                  (make-xhr (cl-format nil mfr-recalls\n                                                                                       (str/replace mfr-name #\&quot;'\&quot; \&quot;\&quot;)\n                                                                                       1)\n                                                                    {:name  :mfr-recall\n                                                                     :send? true\n                                                                     :dbg   mfr-name})))))))))))))})]\n\n\n    (when (xhr-await top)\n      (is (= 200 (xhr-status-key top)))\n      (is (= ae-count (count (md-kids top))))\n      (doseq [ae (md-kids top)]\n        (pln :ae!!!! (md-get ae :ae))\n        (pln :patient (md-get ae :patient))\n        (doseq [drug (md-kids ae)]\n          (pln :drug! (:name @drug) (:ndc @drug))\n          (doseq [info (md-kids drug)]\n            (xhr-dump \&quot;drug-info\&quot; info)\n            (is (some #{(xhr-status-key info)} [200 400])))))\n      (pprint (xhr-to-map top))\n\n      (println :fini!!!!!!!!))))&quot;, :offset 2956, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(defn xhr-to-map [xhr]\n  (case (type xhr)\n    :tiltontec.xhr.core/xhr ;;(keys @xhr) \n    (dissoc @xhr :kids :id :response :select :selection)\n    \n    (select-keys xhr [:type :name :uri])))&quot;, :offset 189, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(defn xhr-to-map [xhr]\n  (case (type xhr)\n    :tiltontec.xhr.core/xhr ;;(keys @xhr)\n    (assoc (dissoc @xhr :par :type :kids :id :response :select :selection)\n      :kids (for [k (:kids @xhr)]\n              (xhr-to-map k)))\n\n    :tiltontec.model.core/family\n    (keys @xhr)\n    \n    (select-keys xhr [:type :name :uri])))&quot;, :offset 321, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(defn xhr-to-map [xhr]\n  (case (type xhr)\n    :tiltontec.xhr.core/xhr ;;(keys @xhr)\n    (assoc (dissoc @xhr :par :type :kids :id :response :select :selection)\n      :kids (for [k (:kids @xhr)]\n              (xhr-to-map k)))\n\n    :tiltontec.model.core/family\n    ;; (keys @xhr)\n    (dissoc @xhr :par :kids :cells-flushed)\n    \n    (select-keys xhr [:type :name :uri])))&quot;, :offset 368, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(defn xhr-to-map [xhr]\n  (case (type xhr)\n    :tiltontec.xhr.core/xhr ;;(keys @xhr)\n    (assoc (dissoc @xhr :par :type :kids :id :response :select :selection)\n      :kids (for [k (:kids @xhr)]\n              (xhr-to-map k)))\n\n    :tiltontec.model.core/family\n    ;; (keys @xhr)\n    (assoc (dissoc @xhr :par :kids :cells-flushed)\n      :kids (for [k (:kids @xhr)]\n              (xhr-to-map k)))\n\n    (select-keys xhr [:type :name :uri])))&quot;, :offset 436, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(defn xhr-to-map [xhr]\n  (case (type xhr)\n    :tiltontec.xhr.core/xhr ;;(keys @xhr)\n    (assoc (dissoc @xhr :par :type :kids :id :response :select :selection)\n      :kids (for [k (:kids @xhr)]\n              (xhr-to-map k)))\n\n    :tiltontec.model.core/family\n    ;; (keys @xhr)\n    (assoc (dissoc @xhr :type :par :kids :cells-flushed)\n      :kids (for [k (:kids @xhr)]\n              (xhr-to-map k)))\n\n    (select-keys xhr [:type :name :uri])))&quot;, :offset 442, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(defn xhr-to-map [xhr]\n  (case (type xhr)\n    :tiltontec.xhr.core/xhr\n    (case (:name @xhr)\n      :drug-label (select-keys @xhr [:name :response])\n\n      (assoc (dissoc @xhr :par :type :kids :id :response :select :selection)\n        :kids (for [k (:kids @xhr)]\n                (xhr-to-map k))))\n\n    :tiltontec.model.core/family\n    ;; (keys @xhr)\n    (assoc (dissoc @xhr :type :par :kids :cells-flushed)\n      :kids (for [k (:kids @xhr)]\n              (xhr-to-map k)))\n\n    (select-keys xhr [:type :name :uri])))&quot;, :offset 514, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(defn xhr-to-map [xhr]\n  (case (type xhr)\n    :tiltontec.xhr.core/xhr\n    (case (:name @xhr)\n      :drug-label {:name :drug-label\n                   :keys (keys (first (:results (:response @xhr))))} ;;(select-keys @xhr [:name :response])\n\n      (assoc (dissoc @xhr :par :type :kids :id :response :select :selection)\n        :kids (for [k (:kids @xhr)]\n                (xhr-to-map k))))\n\n    :tiltontec.model.core/family\n    ;; (keys @xhr)\n    (assoc (dissoc @xhr :type :par :kids :cells-flushed)\n      :kids (for [k (:kids @xhr)]\n              (xhr-to-map k)))\n\n    (select-keys xhr [:type :name :uri])))&quot;, :offset 604, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(defn xhr-to-map [xhr]\n  (case (type xhr)\n    :tiltontec.xhr.core/xhr\n    (case (:name @xhr)\n      :drug-label {:name :drug-label\n                   :keys (do (first (:results (:response @xhr))))} ;;(select-keys @xhr [:name :response])\n\n      (assoc (dissoc @xhr :par :type :kids :id :response :select :selection)\n        :kids (for [k (:kids @xhr)]\n                (xhr-to-map k))))\n\n    :tiltontec.model.core/family\n    ;; (keys @xhr)\n    (assoc (dissoc @xhr :type :par :kids :cells-flushed)\n      :kids (for [k (:kids @xhr)]\n              (xhr-to-map k)))\n\n    (select-keys xhr [:type :name :uri])))&quot;, :offset 602, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(defn xhr-to-map [xhr]\n  (case (type xhr)\n    :tiltontec.xhr.core/xhr\n    (case (:name @xhr)\n      :drug-label {:name :drug-label\n                   :keys (:response @xhr)} ;;(select-keys @xhr [:name :response])\n\n      (assoc (dissoc @xhr :par :type :kids :id :response :select :selection)\n        :kids (for [k (:kids @xhr)]\n                (xhr-to-map k))))\n\n    :tiltontec.model.core/family\n    ;; (keys @xhr)\n    (assoc (dissoc @xhr :type :par :kids :cells-flushed)\n      :kids (for [k (:kids @xhr)]\n              (xhr-to-map k)))\n\n    (select-keys xhr [:type :name :uri])))&quot;, :offset 578, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(defn xhr-to-map [xhr]\n  (case (type xhr)\n    :tiltontec.xhr.core/xhr\n    (case (:name @xhr)\n      :drug-label {:name :drug-label\n                   :keys (:results (:body (:response @xhr)))} ;;(select-keys @xhr [:name :response])\n\n      (assoc (dissoc @xhr :par :type :kids :id :response :select :selection)\n        :kids (for [k (:kids @xhr)]\n                (xhr-to-map k))))\n\n    :tiltontec.model.core/family\n    ;; (keys @xhr)\n    (assoc (dissoc @xhr :type :par :kids :cells-flushed)\n      :kids (for [k (:kids @xhr)]\n              (xhr-to-map k)))\n\n    (select-keys xhr [:type :name :uri])))&quot;, :offset 597, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(defn xhr-to-map [xhr]\n  (case (type xhr)\n    :tiltontec.xhr.core/xhr\n    (case (:name @xhr)\n      :drug-label {:name :drug-label\n                   :keys (keys (first (:results (:body (:response @xhr)))))} ;;(select-keys @xhr [:name :response])\n\n      (assoc (dissoc @xhr :par :type :kids :id :response :select :selection)\n        :kids (for [k (:kids @xhr)]\n                (xhr-to-map k))))\n\n    :tiltontec.model.core/family\n    ;; (keys @xhr)\n    (assoc (dissoc @xhr :type :par :kids :cells-flushed)\n      :kids (for [k (:kids @xhr)]\n              (xhr-to-map k)))\n\n    (select-keys xhr [:type :name :uri])))&quot;, :offset 612, :ns &quot;tiltontec.xhr.core&quot;} {:command &quot;(ns tiltontec.xhr.core-test\n  (:require\n    [clojure.test :refer :all]\n    [clojure.string :as str]\n    [clojure.set :as set]\n    [#?(:cljs cljs.pprint :clj clojure.pprint) :refer [pprint cl-format]]\n    [tiltontec.util.core :refer [pln xor now *plnk-keys*]]\n    [tiltontec.cell.evaluate :refer [c-get c-awaken not-to-be]]\n\n    #?(:clj\n    [tiltontec.cell.base :refer :all]\n       :cljs [tiltontec.cell.base\n              :refer-macros [without-c-dependency]\n              :refer [cells-init +pulse+ unbound cpr]])\n    [tiltontec.cell.integrity :refer [*dp-log*]]\n    [tiltontec.cell.core :refer :all]\n\n    #?(:clj\n    [tiltontec.model.core :refer :all :as md]\n       :cljs [tiltontec.model.core\n              :refer-macros [the-kids mdv!]\n              :refer [md-get fasc fm! make md-reset! backdoor-reset!\n                      mx-par]\n              :as md])\n\n    [tiltontec.xhr.core\n     :refer [make-xhr send-xhr xhr-response xhr-send xhr-await xhr-status\n             xhr-status-key xhr-resolved xhr-error? xhrfo synaptic-xhr\n             xhr-selection xhr-to-map]]\n\n    #?(:clj\n    [tiltontec.cell.synapse :refer :all]\n       :cljs [tiltontec.cell.synapse\n              :refer-macros [with-synapse]\n              :refer []])\n\n    #?(:clj\n    [tiltontec.cell.observer :refer [fn-obs]]\n       :cljs [tiltontec.cell.observer :refer-macros [fn-obs]])\n\n    #?(:clj\n    [tiltontec.tag.gen :refer :all]\n       :cljs [tiltontec.tag.gen :refer [evt-tag target-value] :refer-macros [h1 input div]])\n\n    [cheshire.core :refer :all]\n\n    #?(:clj\n    [clj-http.util :as httpu]\n       :cljs [cljs-http.util :as httpu])\n\n    #?(:clj\n    [clj-http.client :as client]\n       :cljs [cljs-http.client :as client])))&quot;, :offset 1704, :ns &quot;tiltontec.xhr.core-test&quot;} {:command &quot;(ns tiltontec.xhr.core\n  (:require\n    [#?(:cljs cljs.pprint :clj clojure.pprint) :refer [pprint cl-format]]\n\n    [tiltontec.util.core :refer [pln countit]]\n\n    #?(:cljs [tiltontec.cell.base\n              :refer-macros [pcell un-stopped without-c-dependency cpr]\n\n              :refer [+pulse+ c-pulse c-optimized-away?\n                      +client-q-handler+ c-stopped unbound\n                      *within-integrity* *defer-changes*\n                      *depender* caller-ensure]]\n       :clj\n    [tiltontec.cell.base :refer :all])\n\n    #?(:cljs [tiltontec.cell.synapse\n              :refer-macros [with-synapse]\n              :refer []]\n       :clj\n    [tiltontec.cell.synapse :refer :all])\n\n    #?(:cljs [tiltontec.util.base\n              :refer-macros [trx prog1 *trx?* def-rmap-slots]]\n       :clj\n    [tiltontec.util.base\n     :refer :all])\n\n    #?(:clj\n    [tiltontec.cell.observer :refer [fn-obs observe observe-by-type]]\n       :cljs [tiltontec.cell.observer\n              :refer-macros [fn-obs]\n              :refer [observe observe-by-type]])\n\n    #?(:cljs [tiltontec.cell.integrity\n              :refer-macros [with-integrity]]\n       :clj\n    [tiltontec.cell.integrity :refer [with-integrity with-cc]])\n\n    #?(:clj\n    [tiltontec.cell.core :refer :all]\n       :cljs [tiltontec.cell.core\n              :refer-macros [c? c?+ c_? c?_]\n              :refer [c-in c-reset! make-c-formula]])\n\n    [tiltontec.model.core\n     :refer-macros [the-kids mdv!]\n     :refer [md-get fasc fm! make md-reset! backdoor-reset!\n             mx-par]\n     :as md]\n\n\n    #?(:clj\n    [clj-http.client :as client]\n       :cljs [cljs-http.client :as client])\n\n    [cheshire.core :refer :all]))&quot;, :offset 1685, :ns &quot;tiltontec.xhr.core&quot;} {:command &quot;(defn make-xhr\n  ([uri]\n   (make-xhr uri {}))\n\n  ([uri attrs]\n   (assert (string? uri) (str \&quot;param uri &lt;\&quot; uri \&quot;&gt; not a string\&quot;))\n   (let [xhr (apply make\n                    :type :tiltontec.xhr.core/xhr\n                    :id (swap! +xhr-sid+ inc)               ;; debug aid\n                    :uri uri\n                    :response (c-in nil)\n                    :select nil\n                    :selection (c? (when-let [b (xhr-ok-body me)]\n                                     ;; (pln :sel-sees-body!! (md-get me :select) b)\n                                     (if-let [ks (md-get me :select)]\n                                       (select-keys b ks)\n                                       b)))\n                    (vec (apply concat (seq (dissoc attrs :send?)))))]\n     ;;(cpr :made!!!!!!!!!!)\n     (when (:send? attrs)\n       (xhr-send xhr))\n     xhr)))&quot;, :offset 862, :ns &quot;tiltontec.xhr.core&quot;} {:command &quot;(declare xhr-to-map)&quot;, :offset 20, :ns &quot;tiltontec.xhr.core&quot;}], :remote []}}</component>
  <component name="RunDashboard">
    <option name="ruleStates">
      <list>
        <RuleState>
          <option name="name" value="ConfigurationTypeDashboardGroupingRule" />
        </RuleState>
        <RuleState>
          <option name="name" value="StatusDashboardGroupingRule" />
        </RuleState>
      </list>
    </option>
  </component>
  <component name="RunManager" selected="Clojure REPL.nRepl lein">
    <configuration default="true" type="Applet" factoryName="Applet">
      <option name="HTML_USED" value="false" />
      <option name="WIDTH" value="400" />
      <option name="HEIGHT" value="300" />
      <option name="POLICY_FILE" value="$APPLICATION_HOME_DIR$/bin/appletviewer.policy" />
      <module />
    </configuration>
    <configuration default="true" type="Application" factoryName="Application">
      <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea" />
      <option name="MAIN_CLASS_NAME" />
      <option name="VM_PARAMETERS" />
      <option name="PROGRAM_PARAMETERS" />
      <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$" />
      <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
      <option name="ALTERNATIVE_JRE_PATH" />
      <option name="ENABLE_SWING_INSPECTOR" value="false" />
      <option name="ENV_VARIABLES" />
      <option name="PASS_PARENT_ENVS" value="true" />
      <module name="" />
      <envs />
    </configuration>
    <configuration default="true" type="JUnit" factoryName="JUnit">
      <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea" />
      <module name="" />
      <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
      <option name="ALTERNATIVE_JRE_PATH" />
      <option name="PACKAGE_NAME" />
      <option name="MAIN_CLASS_NAME" />
      <option name="METHOD_NAME" />
      <option name="TEST_OBJECT" value="class" />
      <option name="VM_PARAMETERS" value="-ea" />
      <option name="PARAMETERS" />
      <option name="WORKING_DIRECTORY" value="$MODULE_DIR$" />
      <option name="ENV_VARIABLES" />
      <option name="PASS_PARENT_ENVS" value="true" />
      <option name="TEST_SEARCH_SCOPE">
        <value defaultName="singleModule" />
      </option>
      <envs />
      <patterns />
    </configuration>
    <configuration default="true" type="#org.jetbrains.idea.devkit.run.PluginConfigurationType" factoryName="Plugin">
      <module name="" />
      <option name="VM_PARAMETERS" value="-Xmx512m -Xms256m -XX:MaxPermSize=250m -ea" />
      <option name="PROGRAM_PARAMETERS" />
      <predefined_log_file id="idea.log" enabled="true" />
    </configuration>
    <configuration default="true" type="Remote" factoryName="Remote">
      <option name="USE_SOCKET_TRANSPORT" value="true" />
      <option name="SERVER_MODE" value="false" />
      <option name="SHMEM_ADDRESS" value="javadebug" />
      <option name="HOST" value="localhost" />
      <option name="PORT" value="5005" />
    </configuration>
    <configuration default="true" type="TestNG" factoryName="TestNG">
      <extension name="coverage" enabled="false" merge="false" sample_coverage="true" runner="idea" />
      <module name="" />
      <option name="ALTERNATIVE_JRE_PATH_ENABLED" value="false" />
      <option name="ALTERNATIVE_JRE_PATH" />
      <option name="SUITE_NAME" />
      <option name="PACKAGE_NAME" />
      <option name="MAIN_CLASS_NAME" />
      <option name="METHOD_NAME" />
      <option name="GROUP_NAME" />
      <option name="TEST_OBJECT" value="CLASS" />
      <option name="VM_PARAMETERS" value="-ea" />
      <option name="PARAMETERS" />
      <option name="WORKING_DIRECTORY" value="$MODULE_DIR$" />
      <option name="OUTPUT_DIRECTORY" />
      <option name="ANNOTATION_TYPE" />
      <option name="ENV_VARIABLES" />
      <option name="PASS_PARENT_ENVS" value="true" />
      <option name="TEST_SEARCH_SCOPE">
        <value defaultName="singleModule" />
      </option>
      <option name="USE_DEFAULT_REPORTERS" value="false" />
      <option name="PROPERTIES_FILE" />
      <envs />
      <properties />
      <listeners />
    </configuration>
    <configuration name="nRepl lein" type="ClojureREPL" factoryName="Local">
      <setting name="replType" value="1" />
      <module name="todomx" />
      <setting name="jvmArgs" value="" />
      <setting name="parameters" value="" />
      <setting name="workingDir" value="$PROJECT_DIR$" />
      <setting name="profiles" value="" />
      <method>
        <option name="Make" enabled="true" />
      </method>
    </configuration>
  </component>
  <component name="ShelveChangesManager" show_recycled="false">
    <option name="remove_strategy" value="false" />
  </component>
  <component name="TaskManager">
    <task active="true" id="Default" summary="Default task">
      <changelist id="ef97d307-f487-4c12-a37c-953b69f2764e" name="Default" comment="" />
      <created>1508909234004</created>
      <option name="number" value="Default" />
      <option name="presentableId" value="Default" />
      <updated>1508909234004</updated>
    </task>
    <servers />
  </component>
  <component name="ToolWindowManager">
    <frame x="218" y="67" width="1494" height="922" extended-state="0" />
    <editor active="true" />
    <layout>
      <window_info id="TODO" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="6" side_tool="false" content_ui="tabs" />
      <window_info id="Palette&#9;" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="3" side_tool="false" content_ui="tabs" />
      <window_info id="Image Layers" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Capture Analysis" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="3" side_tool="false" content_ui="tabs" />
      <window_info id="Event Log" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.32934132" sideWeight="0.5" order="7" side_tool="true" content_ui="tabs" />
      <window_info id="Maven Projects" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="3" side_tool="false" content_ui="tabs" />
      <window_info id="REPL" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="true" show_stripe_button="true" weight="0.1914324" sideWeight="0.5" order="3" side_tool="true" content_ui="tabs" x="706" y="472" width="601" height="455" />
      <window_info id="Run" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Version Control" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="7" side_tool="false" content_ui="tabs" />
      <window_info id="Leiningen" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="3" side_tool="false" content_ui="tabs" />
      <window_info id="Terminal" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="7" side_tool="false" content_ui="tabs" />
      <window_info id="Capture Tool" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Designer" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Project" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="true" show_stripe_button="true" weight="0.23427041" sideWeight="0.5" order="0" side_tool="false" content_ui="combo" />
      <window_info id="Find" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.32855436" sideWeight="0.5" order="1" side_tool="false" content_ui="tabs" />
      <window_info id="Structure" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="1" side_tool="false" content_ui="tabs" />
      <window_info id="Ant Build" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="1" side_tool="false" content_ui="tabs" />
      <window_info id="Theme Preview" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="3" side_tool="false" content_ui="tabs" />
      <window_info id="Debug" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.39904422" sideWeight="0.5" order="3" side_tool="false" content_ui="tabs" />
      <window_info id="Favorites" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="true" content_ui="tabs" />
      <window_info id="Cvs" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="4" side_tool="false" content_ui="tabs" />
      <window_info id="Message" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="0" side_tool="false" content_ui="tabs" />
      <window_info id="Commander" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.4" sideWeight="0.5" order="0" side_tool="false" content_ui="tabs" />
      <window_info id="Hierarchy" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="2" side_tool="false" content_ui="combo" />
      <window_info id="Messages" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="7" side_tool="false" content_ui="tabs" />
      <window_info id="Documentation" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="FLOATING" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="4" side_tool="false" content_ui="tabs" x="117" y="162" width="1431" height="707" />
      <window_info id="Inspection" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.4" sideWeight="0.5" order="5" side_tool="false" content_ui="tabs" />
    </layout>
    <layout-to-restore>
      <window_info id="Cvs" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="4" side_tool="false" content_ui="tabs" />
      <window_info id="Message" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="0" side_tool="false" content_ui="tabs" />
      <window_info id="Commander" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.4" sideWeight="0.5" order="0" side_tool="false" content_ui="tabs" />
      <window_info id="Event Log" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.32934132" sideWeight="0.5" order="7" side_tool="true" content_ui="tabs" />
      <window_info id="Maven Projects" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="3" side_tool="false" content_ui="tabs" />
      <window_info id="REPL" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="FLOATING" visible="true" show_stripe_button="true" weight="0.29657796" sideWeight="0.5" order="4" side_tool="true" content_ui="tabs" x="1842" y="-627" width="845" height="1494" />
      <window_info id="Leiningen" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="5" side_tool="false" content_ui="tabs" />
      <window_info id="Capture Tool" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Designer" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="3" side_tool="false" content_ui="tabs" />
      <window_info id="Hierarchy" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="2" side_tool="false" content_ui="combo" />
      <window_info id="Structure" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="1" side_tool="false" content_ui="tabs" />
      <window_info id="Ant Build" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="1" side_tool="false" content_ui="tabs" />
      <window_info id="Debug" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.4" sideWeight="0.5" order="3" side_tool="false" content_ui="tabs" />
      <window_info id="TODO" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="6" side_tool="false" content_ui="tabs" />
      <window_info id="Messages" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="8" side_tool="false" content_ui="tabs" />
      <window_info id="Palette&#9;" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="6" side_tool="false" content_ui="tabs" />
      <window_info id="Image Layers" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="4" side_tool="false" content_ui="tabs" />
      <window_info id="Capture Analysis" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="7" side_tool="false" content_ui="tabs" />
      <window_info id="Documentation" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="FLOATING" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="9" side_tool="false" content_ui="tabs" x="117" y="162" width="1431" height="707" />
      <window_info id="Inspection" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.4" sideWeight="0.5" order="5" side_tool="false" content_ui="tabs" />
      <window_info id="Run" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
      <window_info id="Version Control" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="false" weight="0.33" sideWeight="0.5" order="9" side_tool="false" content_ui="tabs" />
      <window_info id="Terminal" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="10" side_tool="false" content_ui="tabs" />
      <window_info id="Project" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="true" show_stripe_button="true" weight="0.21459228" sideWeight="0.5" order="0" side_tool="false" content_ui="combo" />
      <window_info id="Find" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.32934132" sideWeight="0.5" order="1" side_tool="false" content_ui="tabs" />
      <window_info id="Theme Preview" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="8" side_tool="false" content_ui="tabs" />
      <window_info id="Favorites" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="5" side_tool="true" content_ui="tabs" />
    </layout-to-restore>
  </component>
  <component name="VcsContentAnnotationSettings">
    <option name="myLimit" value="2678400000" />
  </component>
  <component name="XDebuggerManager">
    <breakpoint-manager>
      <breakpoints>
        <line-breakpoint enabled="true" type="java-line">
          <url>file://$PROJECT_DIR$/src/tiltontec/cell/base.cljc</url>
          <line>184</line>
          <properties />
          <option name="timeStamp" value="1" />
        </line-breakpoint>
      </breakpoints>
      <option name="time" value="5" />
    </breakpoint-manager>
    <watches-manager />
  </component>
  <component name="editorHistoryManager">
    <entry file="file://$PROJECT_DIR$/src/todomx/core.cljs" />
    <entry file="file://$PROJECT_DIR$/src/todomx/ticktock.cljs" />
    <entry file="file://$PROJECT_DIR$/src/todomx/startwatch.cljs" />
    <entry file="file://$PROJECT_DIR$/startwatch.html" />
    <entry file="file://$PROJECT_DIR$/css/startwatch.css" />
    <entry file="file://$PROJECT_DIR$/ticktock.html" />
    <entry file="file://$PROJECT_DIR$/src/todomx/core.cljs" />
    <entry file="file://$PROJECT_DIR$/src/todomx/ticktock.cljs" />
    <entry file="file://$PROJECT_DIR$/src/todomx/startwatch.cljs" />
    <entry file="file://$PROJECT_DIR$/startwatch.html" />
    <entry file="file://$PROJECT_DIR$/css/startwatch.css" />
    <entry file="file://$PROJECT_DIR$/ticktock.html" />
    <entry file="file://$PROJECT_DIR$/src/todomx/core.cljs" />
    <entry file="file://$PROJECT_DIR$/src/todomx/ticktock.cljs" />
    <entry file="file://$PROJECT_DIR$/src/todomx/startwatch.cljs" />
    <entry file="file://$PROJECT_DIR$/startwatch.html" />
    <entry file="file://$PROJECT_DIR$/css/startwatch.css" />
    <entry file="file://$PROJECT_DIR$/ticktock.html" />
    <entry file="file://$PROJECT_DIR$/src/todomx/core.cljs" />
    <entry file="file://$PROJECT_DIR$/src/todomx/ticktock.cljs" />
    <entry file="file://$PROJECT_DIR$/src/todomx/startwatch.cljs" />
    <entry file="file://$PROJECT_DIR$/src/todomx/core.cljs" />
    <entry file="file://$PROJECT_DIR$/src/todomx/ticktock.cljs" />
    <entry file="file://$PROJECT_DIR$/css/startwatch.css" />
    <entry file="file://$PROJECT_DIR$/ticktock.html" />
    <entry file="file://$PROJECT_DIR$/startwatch.html" />
    <entry file="jar://$MAVEN_REPOSITORY$/se/haleby/stub-http/0.2.3/stub-http-0.2.3.jar!/stub_http/core.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="624">
          <caret line="77" column="10" lean-forward="false" selection-start-line="77" selection-start-column="10" selection-end-line="77" selection-end-column="10" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/test/tiltontec/cell/XHR/core.clj" />
    <entry file="jar://$MAVEN_REPOSITORY$/org/clojure/clojure/1.8.0/clojure-1.8.0.jar!/clojure/core.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="269">
          <caret line="2018" column="6" lean-forward="false" selection-start-line="2018" selection-start-column="6" selection-end-line="2018" selection-end-column="6" />
        </state>
      </provider>
    </entry>
    <entry file="jar:///Library/Java/JavaVirtualMachines/jdk1.8.0_152.jdk/Contents/Home/src.zip!/java/lang/StringIndexOutOfBoundsException.java">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="225">
          <caret line="38" column="6" lean-forward="false" selection-start-line="38" selection-start-column="6" selection-end-line="38" selection-end-column="6" />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/test/tiltontec/cell/synapse_test.cljc" />
    <entry file="file://$PROJECT_DIR$/src/tiltontec/util/base.cljc" />
    <entry file="file://$PROJECT_DIR$/test/tiltontec/xhr/core_test.cljc" />
    <entry file="file://$PROJECT_DIR$/src/tiltontec/xhr/core.cljc" />
    <entry file="file://$PROJECT_DIR$/src/tiltontec/cell/base.cljc" />
    <entry file="file://$PROJECT_DIR$/src/tiltontec/cell/integrity.cljc" />
    <entry file="file://$PROJECT_DIR$/src/todomx/todo.cljs" />
    <entry file="file://$PROJECT_DIR$/src/tiltontec/tag/html.cljs" />
    <entry file="file://$PROJECT_DIR$/src/tiltontec/tag/gen.cljc" />
    <entry file="file://$PROJECT_DIR$/src/tiltontec/cell/core.cljc" />
    <entry file="file://$PROJECT_DIR$/src/todomx/todomvc.cljs" />
    <entry file="file://$PROJECT_DIR$/src/todomx/ticktock.cljs" />
    <entry file="file://$PROJECT_DIR$/src/todomx/startwatch.cljs" />
    <entry file="file://$PROJECT_DIR$/src/todomx/core.cljs" />
    <entry file="file://$PROJECT_DIR$/src/tiltontec/cell/synapse.cljc">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="435">
          <caret line="29" column="55" lean-forward="false" selection-start-line="29" selection-start-column="55" selection-end-line="29" selection-end-column="55" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/example/gentle_intro.cljs" />
    <entry file="file://$PROJECT_DIR$/project.clj">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="0">
          <caret line="0" column="39" lean-forward="false" selection-start-line="0" selection-start-column="39" selection-end-line="0" selection-end-column="39" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/tiltontec/model/base.cljc">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="372">
          <caret line="78" column="18" lean-forward="false" selection-start-line="78" selection-start-column="18" selection-end-line="78" selection-end-column="18" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/tiltontec/util/core.cljc">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="260">
          <caret line="53" column="6" lean-forward="false" selection-start-line="53" selection-start-column="6" selection-end-line="53" selection-end-column="6" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/tiltontec/model/core.cljc">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="464">
          <caret line="150" column="15" lean-forward="false" selection-start-line="150" selection-start-column="15" selection-end-line="150" selection-end-column="15" />
          <folding />
        </state>
      </provider>
    </entry>
    <entry file="file://$PROJECT_DIR$/src/tiltontec/cell/evaluate.cljc">
      <provider selected="true" editor-type-id="text-editor">
        <state relative-caret-position="269">
          <caret line="405" column="5" lean-forward="false" selection-start-line="405" selection-start-column="5" selection-end-line="405" selection-end-column="5" />
          <folding />
        </state>
      </provider>
    </entry>
  </component>
  <component name="masterDetails">
    <states>
      <state key="ArtifactsStructureConfigurable.UI">
        <settings>
          <artifact-editor />
          <splitter-proportions>
            <option name="proportions">
              <list>
                <option value="0.2" />
              </list>
            </option>
          </splitter-proportions>
        </settings>
      </state>
      <state key="FacetStructureConfigurable.UI">
        <settings>
          <last-edited>No facets are configured</last-edited>
          <splitter-proportions>
            <option name="proportions">
              <list>
                <option value="0.2" />
              </list>
            </option>
          </splitter-proportions>
        </settings>
      </state>
      <state key="GlobalLibrariesConfigurable.UI">
        <settings>
          <splitter-proportions>
            <option name="proportions">
              <list>
                <option value="0.2" />
              </list>
            </option>
          </splitter-proportions>
        </settings>
      </state>
      <state key="JdkListConfigurable.UI">
        <settings>
          <last-edited>1.8</last-edited>
          <splitter-proportions>
            <option name="proportions">
              <list>
                <option value="0.2" />
              </list>
            </option>
          </splitter-proportions>
        </settings>
      </state>
      <state key="ModuleStructureConfigurable.UI">
        <settings>
          <last-edited>todomx</last-edited>
          <splitter-proportions>
            <option name="proportions">
              <list>
                <option value="0.2" />
                <option value="0.6" />
              </list>
            </option>
          </splitter-proportions>
        </settings>
      </state>
      <state key="ProjectJDKs.UI">
        <settings>
          <splitter-proportions>
            <option name="proportions">
              <list>
                <option value="0.2" />
              </list>
            </option>
          </splitter-proportions>
        </settings>
      </state>
      <state key="ProjectLibrariesConfigurable.UI">
        <settings>
          <last-edited>Leiningen: args4j:2.33</last-edited>
          <splitter-proportions>
            <option name="proportions">
              <list>
                <option value="0.2" />
              </list>
            </option>
          </splitter-proportions>
        </settings>
      </state>
    </states>
  </component>
</project>